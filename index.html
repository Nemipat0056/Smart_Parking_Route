
<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Plotly for statistics charts -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Smart Parking Search - Intelligent Parking Solutions</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      min-height: 100vh;
      color: #333;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }
    
    /* Video Background */
    .video-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      object-fit: cover;
    }
    
    .video-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.7) 0%, rgba(118, 75, 162, 0.7) 100%);
      z-index: -1;
    }

    .header {
      background: rgba(255, 255, 255, 0.98);
      backdrop-filter: blur(15px);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 25px rgba(0, 0, 0, 0.15);
      position: sticky;
      top: 0;
      z-index: 1000;
      border-bottom: 1px solid rgba(102, 126, 234, 0.1);
    }
        .nav-link:hover {
      color: #5a67d8 !important;
      transform: translateY(-1px);
    }

    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
      animation: fadeIn 0.3s ease;
    }

    .modal-content {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.9));
      backdrop-filter: blur(20px);
      margin: 2% auto;
      padding: 0;
      border-radius: 20px;
      max-width: 900px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
      animation: slideIn 0.3s ease;
      border: 1px solid rgba(102, 126, 234, 0.1);
    }

    @keyframes slideIn {
      from { transform: translateY(-50px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .modal-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 1.5rem 2rem;
      border-radius: 20px 20px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 1.5rem;
      font-weight: 700;
    }

    .close {
      color: white;
      font-size: 2rem;
      font-weight: bold;
      cursor: pointer;
      background: none;
      border: none;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background-color 0.3s ease;
    }

    .close:hover {
      background-color: rgba(255, 255, 255, 0.2);
    }

    .modal-body {
      padding: 2rem;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: bold;
      color: #667eea;
    }

    .user-section {
      display: none;
      align-items: center;
      gap: 1rem;
    }

    .user-greeting {
      font-weight: 500;
    }

    .logout-btn {
      background: #ff6b6b;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .logout-btn:hover {
      background: #ff5252;
      transform: translateY(-1px);
    }

    .main-container {
      max-width: 1400px;
      margin: 2rem auto;
      padding: 0 2rem;
    }



    .main-content {
      background: rgba(255, 255, 255, 0.98);
      backdrop-filter: blur(15px);
      border-radius: 16px;
      padding: 0;
      box-shadow: 0 8px 40px rgba(0, 0, 0, 0.15);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    /* Tab Navigation Styles */
    .tab-navigation {
      display: flex;
      background: rgba(102, 126, 234, 0.05);
      border-bottom: 2px solid rgba(102, 126, 234, 0.1);
    }

    .tab-button {
      flex: 1;
      padding: 1.5rem 2rem;
      background: none;
      border: none;
      color: #666;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .tab-button:hover {
      background: rgba(102, 126, 234, 0.1);
      color: #667eea;
    }

    .tab-button.active {
      background: white;
      color: #667eea;
      border-bottom: 3px solid #667eea;
    }

    .tab-button.active::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(135deg, #667eea, #764ba2);
    }

    /* Tab Content Styles */
    .tab-content {
      display: none;
      padding: 2rem;
      animation: fadeIn 0.3s ease-in-out;
    }

    .tab-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .tab-placeholder {
      text-align: center;
      padding: 4rem 2rem;
      color: #666;
    }

    .tab-placeholder h3 {
      color: #667eea;
      margin-bottom: 1rem;
      font-size: 1.5rem;
    }

    .tab-placeholder p {
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
    }

    .coming-soon {
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: bold;
      font-size: 1.2rem;
      margin-top: 1rem;
    }

    /* Modern Search Section Styles */
    .search-section {
      margin-bottom: 3rem;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.03), rgba(118, 75, 162, 0.03));
      border-radius: 20px;
      padding: 2rem;
      border: 1px solid rgba(102, 126, 234, 0.08);
    }

    .search-section h4 {
      color: #667eea;
      font-size: 1.3rem;
      margin-bottom: 1.5rem;
      font-weight: 700;
    }

    .search-input-group {
      display: grid;
      grid-template-columns: 2fr 1fr auto;
      gap: 1rem;
      margin-bottom: 1.5rem;
      align-items: center;
    }

    input[type="text"], select {
      padding: 1.2rem 1.5rem;
      border: 2px solid rgba(102, 126, 234, 0.1);
      border-radius: 16px;
      font-size: 1rem;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
      font-weight: 500;
    }

    input[type="text"] {
      position: relative;
    }

    input[type="text"]::placeholder {
      color: #94a3b8;
      font-weight: 400;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #667eea;
      background: white;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.08), 0 4px 20px rgba(102, 126, 234, 0.12);
      transform: translateY(-1px);
    }

    select {
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
      background-position: right 1rem center;
      background-repeat: no-repeat;
      background-size: 1rem;
      padding-right: 3rem;
    }

    button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 1.2rem 2rem;
      border-radius: 16px;
      cursor: pointer;
      font-weight: 600;
      font-size: 1rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      min-width: fit-content;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
      position: relative;
      overflow: hidden;
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(102, 126, 234, 0.4);
      background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
    }

    button:hover:not(:disabled)::before {
      left: 100%;
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .parking-filters {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
      margin: 1.5rem 0;
      padding: 1.5rem;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 16px;
      border: 1px solid rgba(102, 126, 234, 0.05);
    }

    .parking-filters label {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      font-weight: 600;
      color: #4a5568;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .parking-filters select {
      margin-top: 0.5rem;
      padding: 0.8rem 1rem;
      font-size: 0.95rem;
      border-radius: 12px;
    }

    .map-container {
      width: 100%;
      height: 400px;
      border-radius: 12px;
      overflow: hidden;
      margin: 1rem 0;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .info, .error, .success {
      padding: 1rem;
      border-radius: 12px;
      margin: 1rem 0;
      font-weight: 500;
    }

    .info {
      background: rgba(33, 150, 243, 0.1);
      color: #1976d2;
      border-left: 4px solid #2196f3;
    }

    .error {
      background: rgba(244, 67, 54, 0.1);
      color: #d32f2f;
      border-left: 4px solid #f44336;
    }

    .success {
      background: rgba(76, 175, 80, 0.1);
      color: #388e3c;
      border-left: 4px solid #4caf50;
    }

    .results-section {
      margin-top: 2rem;
    }

    .results-count {
      font-size: 0.9rem;
      color: #6b7280;
      margin-bottom: 1rem;
      padding: 0.5rem 1rem;
      background: rgba(102, 126, 234, 0.05);
      border-radius: 8px;
      border-left: 4px solid #667eea;
    }

    .parking-results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1.5rem;
      margin-top: 1rem;
    }

    .parking-spot {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.85));
      backdrop-filter: blur(10px);
      padding: 1.8rem;
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      border: 2px solid rgba(102, 126, 234, 0.08);
      position: relative;
      overflow: hidden;
    }

    .parking-spot::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .parking-spot:hover {
      transform: translateY(-4px) scale(1.02);
      box-shadow: 0 16px 48px rgba(0, 0, 0, 0.12);
      border-color: rgba(102, 126, 234, 0.2);
    }

    .parking-spot:hover::before {
      opacity: 1;
    }

    .parking-spot h5 {
      color: #1a202c;
      margin-bottom: 1.2rem;
      font-size: 1.2rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      display: inline-block;
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8);
      animation: pulse 2s infinite;
    }

    .status-free {
      background: #10b981;
    }

    .status-occupied {
      background: #ef4444;
    }

    .status-reserved {
      background: #f59e0b;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .parking-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.8rem;
      font-size: 0.9rem;
      padding: 0.5rem 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }

    .parking-info:last-of-type {
      border-bottom: none;
      margin-bottom: 1rem;
    }

    .parking-info span:first-child {
      font-weight: 600;
      color: #4a5568;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .parking-info span:last-child {
      font-weight: 700;
      color: #1a202c;
      background: rgba(102, 126, 234, 0.1);
      padding: 0.25rem 0.75rem;
      border-radius: 8px;
      font-size: 0.9rem;
    }

    .eco-badge, .ev-badge {
      display: inline-block;
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      padding: 0.4rem 0.8rem;
      border-radius: 12px;
      font-size: 0.8rem;
      font-weight: 600;
      margin: 0.25rem 0.25rem 0.25rem 0;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .ev-badge {
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    .parking-actions {
      display: flex;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }

    .navigate-btn {
      flex: 1;
      background: linear-gradient(135deg, #10b981, #059669);
      font-size: 0.9rem;
      font-weight: 600;
      padding: 1rem 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      border-radius: 14px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .navigate-btn:hover {
      background: linear-gradient(135deg, #059669, #047857);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
    }

    .current-choice {
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.05), rgba(102, 126, 234, 0.02));
      border: 2px solid #667eea !important;
      position: relative;
    }

    .current-choice::after {
      content: '✓ Your Choice';
      position: absolute;
      top: -8px;
      right: 12px;
      background: #667eea;
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    @media (max-width: 768px) {
      .header {
        padding: 1rem;
        flex-direction: column;
        gap: 1rem;
      }

      .main-container {
        padding: 0 1rem;
      }

      .tab-button {
        padding: 1rem;
        font-size: 0.9rem;
      }

      .tab-content {
        padding: 1rem;
      }

      .search-input-group {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .search-section {
        padding: 1.5rem;
        margin-bottom: 2rem;
      }

      .parking-filters {
        grid-template-columns: 1fr;
        gap: 1rem;
        padding: 1rem;
      }

      .parking-results-grid {
        grid-template-columns: 1fr;
      }

      input[type="text"], select, button {
        padding: 1rem 1.2rem;
        font-size: 0.95rem;
      }

      /* notes & insights */
      .muted-note{color:#6b7280;font-size:.85rem;margin-top:.35rem}
      .insight-box{
        background:rgba(102,126,234,.06);
        border:1px solid rgba(102,126,234,.15);
        color:#374151;
        border-radius:12px;
        padding:12px 14px;
        margin:10px 0 16px 0;
        line-height:1.55;
      }
      .insight-box em{font-style:normal;color:#667eea;font-weight:600}
      }
      
      /* Statistics charts grid */
      .stats-charts-grid{
        display:grid;
        grid-template-columns: 1fr 1fr;
        gap: 1.5rem;
      }

      /* 手机端：改为单列，并给图更高的可视高度 */
      @media (max-width: 768px){
        .stats-charts-grid{ grid-template-columns: 1fr !important; }
        #stats-chart1, #stats-chart2{ height: 420px !important; }
      }



  </style>
</head>
<body>
  <!-- Video Background -->
  <video class="video-background" autoplay muted loop playsinline>
    <source src="https://smartrouteparking.s3.ap-southeast-2.amazonaws.com/Background.mp4" type="video/mp4">
    <!-- Fallback for browsers that don't support video -->
    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); width: 100%; height: 100%;"></div>
  </video>
  
  <!-- Video Overlay for better readability -->
  <div class="video-overlay"></div>
  <!-- Header -->
  <header class="header">
    <div class="logo">🅿️ Smart Parking Search</div>
    <!-- Navigation Menu -->
    <nav class="header-nav" style="display: flex; align-items: center; gap: 2rem;">
      <a href="#about" class="nav-link" onclick="showAboutModal(); return false;" style="color: #667eea; text-decoration: none; font-weight: 500; transition: color 0.3s ease;">ℹ️ About Us</a>
    </nav>
    <div class="user-section">
      <div id="userGreeting" class="user-greeting">Loading...</div>
      <button id="logoutBtn" class="logout-btn" style="display: none;">Logout</button>
    </div>
  </header>

  <!-- Main Container -->
  <div class="main-container">
    <!-- Main Content -->
    <div class="main-content">
      <!-- Tab Navigation -->
      <div class="tab-navigation">
        <button class="tab-button active" data-tab="parking">
          🅿️ Find Parking Spots
        </button>
        <button class="tab-button" data-tab="statistics">
          📊 Statistics
        </button>
        <button class="tab-button" data-tab="eco">
          🌱 Eco Planning
        </button>
      </div>

      <!-- Tab Content: Find Parking Spots -->
      <div class="tab-content active" id="parking-tab">
        <h3>🅿️ Find Parking Spots</h3>

        <!-- Search Section -->
        <div class="search-section">
          <h4>Search for Parking</h4>
          <div class="search-input-group">
            <input type="text" id="parkingLocationInput" placeholder="Enter location or address" />
            <select id="parkingTypeSelect">
              <option value="all">All Types</option>
              <option value="street">Street Parking</option>
              <option value="garage">Parking Garage</option>
              <option value="lot">Parking Lot</option>
              <option value="private">Private Parking</option>
            </select>
            <button id="searchParkingBtn">Search Parking</button>
          </div>

          <div class="parking-filters">
            <label>Max Distance:
              <select id="maxDistanceSelect">
                <option value="0.5">0.5 km</option>
                <option value="1">1 km</option>
                <option value="2" selected>2 km</option>
                <option value="5">5 km</option>
                <option value="10">10 km</option>
                <option value="20">20 km (All Melbourne)</option>
              </select>
            </label>

            <label>Parking Restrictions:
              <select id="restrictionSelect">
                <option value="all">All Restrictions</option>
                <option value="norestriction">No Restriction</option>
                <option value="shortterm">Short Term (≤2hr)</option>
                <option value="mediumterm">Medium Term (3-8hr)</option>
                <option value="longterm">Long Term (>8hr)</option>
                <option value="permit">Permit Only</option>
                <option value="loading">Loading Zone</option>
              </select>
            </label>

            <label>Availability:
              <select id="availabilitySelect">
                <option value="all">All Spots</option>
                <option value="available">🟢 Available Only</option>
                <option value="occupied">🔴 Occupied Only</option>
                <option value="reserved">🟡 Reserved Only</option>
              </select>
            </label>
          </div>

          <div id="parkingSearchStatus" class="info">Ready to search for parking spots across all Melbourne areas</div>

          <!-- Google Map for Parking Search -->
          <div id="parkingMap" class="map-container"></div>
        </div>

        <!-- Parking Results Section -->
        <div id="parkingResultsSection" class="results-section" style="display: none;">
          <h4>Available Parking Spots</h4>
          <div id="parkingResultsCount" class="results-count"></div>
          <div id="parkingResultsGrid" class="parking-results-grid"></div>
        </div>
      </div>

      <!-- Tab Content: Statistics -->
      <div class="tab-content" id="statistics-tab">
        <h3>📊 Melbourne Traffic & Population Statistics</h3>

        <!-- Statistics Controls Section -->
        <div class="search-section">
          <h4>Interactive Analysis Controls</h4>
          <p style="color: #6b7280; margin-bottom: 1.5rem;">Pick a region and year, enter your household vehicles. See where your household sits in the distribution and what it means for congestion.</p>

          <div class="parking-filters">
            <label>Region:
              <select id="stats-region">
                <option>City of Melbourne</option>
                <option>Suburb Melbourne</option>
                <option>Greater Melbourne (All)</option>
              </select>
            </label>

            <label>Year:
              <select id="stats-year">
                <option value="2001">2001</option>
                <option value="2006">2006</option>
                <option value="2011">2011</option>
                <option value="2016">2016</option>
                <option value="2021" selected>2021</option>
              </select>
            </label>

            <label>Vehicles in household:
              <select id="stats-hhcars">
                <option value="0">0</option>
                <option value="1" selected>1</option>
                <option value="2">2</option>
                <option value="3">3+</option>
              </select>
            </label>
          </div>

        </div>

        <!-- KPI Display Section -->
        <div class="search-section">
          <h4>Key Metrics</h4>
          <div class="parking-results-grid">
            <div class="parking-spot">
              <h5>📈 Population</h5>
              <div class="parking-info">
                <span>Current Population</span>
                <span id="stats-pop" style="font-size: 1.2rem; font-weight: bold;">-</span>
              </div>
              <p class="muted-note">Higher population with limited road space increases congestion pressure.</p>
            </div>

            <div class="parking-spot">
              <h5>🚗 Vehicle Density</h5>
              <div class="parking-info">
                <span>Vehicles per 1,000 people</span>
                <span id="stats-vp1000" style="font-size: 1.2rem; font-weight: bold;">-</span>
              </div>
              <p class="muted-note">More cars per 1,000 people means higher road use and potential traffic delays.</p>
            </div>

            <div class="parking-spot">
              <h5>🏠 Your Household</h5>
              
              <div class="parking-info">
                <span>Your percentile</span>
                <span id="stats-percentile" style="font-size: 1.2rem; font-weight: bold;">-</span>
              </div>
              <p class="muted-note">Percentile shows the share of households with <em>equal or fewer</em> cars than yours.</p>
            </div>
          </div>
        </div>

        <!-- Charts Section -->
        <div class="search-section">
          <h4>Visual Analysis</h4>
          <div id="stats-insights" class="insight-box">
            In {region}, the population grew by {X%} from {firstYear} to {lastYear}, while household vehicle ownership grew by {Y%}. This indicates that {summary}.
          </div>
          <div class="stats-charts-grid">
            <div id="stats-chart1" class="map-container" style="height: 400px; background: white;"></div>
            <div id="stats-chart2" class="map-container" style="height: 400px; background: white;"></div>
          </div>
        </div>

        <!-- Data Sources -->
        <div class="search-section">
          <h4>📚 Data Sources</h4>
          <div class="info">
            <ul style="margin-left: 1.5rem; line-height: 1.8;">
              <li>Australian Bureau of Statistics (ABS) — Regional population 2021:
                <a href="https://www.abs.gov.au/statistics/people/population/regional-population/2021/32180DS0001_2001-21.xlsx" target="_blank" style="color: #667eea;">ABS 2001–21 dataset</a>
              </li>
              <li>City of Melbourne — Number of cars per household:
                <a href="https://profile.id.com.au/melbourne/car-ownership?EndYear=2011&DataType=EN" target="_blank" style="color: #667eea;">profile.id: Car ownership</a>
              </li>
            </ul>
           
          </div>
        </div>
      </div>



      <!-- Tab Content: Eco Planning -->
      <div class="tab-content" id="eco-tab">
        <h3>🌱 Eco-Friendly Planning</h3>

        <!-- Carbon Footprint Calculator Section -->
        <div class="search-section">
          <h4>🌍 Carbon Footprint Calculator</h4>
          <div class="search-input-group">
            <input type="text" id="ecoTripOrigin" placeholder="From (your location)" />
            <input type="text" id="ecoTripDestination" placeholder="To (destination)" />
            <button id="calculateEcoBtn">Calculate Impact</button>
          </div>

          <div class="parking-filters">
            <label>Transport Mode:
              <select id="transportModeSelect">
                <option value="car">🚗 Private Car</option>
                <option value="public">🚊 Public Transport</option>
                <option value="bike">🚴 Cycling</option>
                <option value="walk">🚶 Walking</option>
                <option value="carpool">👥 Carpool (2+ people)</option>
              </select>
            </label>

            <label>Car Type (if applicable):
              <select id="carTypeSelect">
                <option value="petrol">⛽ Petrol Car</option>
                <option value="hybrid">🔋 Hybrid</option>
                <option value="electric">⚡ Electric</option>
                <option value="diesel">🛢️ Diesel</option>
              </select>
            </label>

            <label>Trip Frequency:
              <select id="tripFrequencySelect">
                <option value="daily">📅 Daily Commute</option>
                <option value="weekly">📅 Weekly</option>
                <option value="monthly">📅 Monthly</option>
                <option value="once">📅 One-time Trip</option>
              </select>
            </label>
          </div>

          <div id="ecoCalculationStatus" class="info">Enter your trip details to calculate environmental impact</div>

          <!-- Results Display -->
          <div id="ecoResultsSection" class="results-section" style="display: none;">
            <h4>🌱 Environmental Impact Results</h4>
            <div id="ecoComparisonGrid" class="parking-results-grid"></div>
          </div>
        </div>

        <!-- Green Parking Recommendations Section -->
        <div class="search-section">
          <h4>🅿️ Green Parking Recommendations</h4>
          <div class="search-input-group">
            <input type="text" id="greenParkingLocation" placeholder="Search location for eco-friendly parking" />
            <select id="greenFilterSelect">
              <option value="all">🌿 All Green Options</option>
              <option value="publictransport">🚊 Near Public Transport</option>
              <option value="evcharging">⚡ EV Charging Available</option>
              <option value="bikeparking">🚴 Bike Parking Nearby</option>
              <option value="lowcongestion">🚗 Low Congestion Areas</option>
            </select>
            <button id="searchGreenParkingBtn">Find Green Parking</button>
          </div>

          <div id="greenParkingStatus" class="info">Find parking options that support sustainable transportation</div>

          <!-- Green Parking Map -->
          <div id="greenParkingMap" class="map-container"></div>

          <!-- Green Parking Results -->
          <div id="greenParkingResultsSection" class="results-section" style="display: none;">
            <h4>🌱 Eco-Friendly Parking Options</h4>
            <div id="greenParkingResultsCount" class="results-count"></div>
            <div id="greenParkingResultsGrid" class="parking-results-grid"></div>
          </div>
        </div>

        <!-- Sustainability Tips Section -->
        <div class="search-section">
          <h4>💡 Sustainability Tips</h4>
          <div class="parking-results-grid">
            <div class="parking-spot">
              <h5>🚊 Park & Ride</h5>
              <div class="parking-info">
                <span>Tip</span>
                <span>Park at train stations and use public transport for CBD access</span>
              </div>
              <div class="parking-info">
                <span>CO2 Savings</span>
                <span>Up to 80% reduction in emissions</span>
              </div>
              <div class="eco-badge">🌱 Highly Recommended</div>
            </div>

            <div class="parking-spot">
              <h5>👥 Carpooling</h5>
              <div class="parking-info">
                <span>Tip</span>
                <span>Share rides with colleagues or use carpooling apps</span>
              </div>
              <div class="parking-info">
                <span>CO2 Savings</span>
                <span>50% reduction per person with 2 people</span>
              </div>
              <div class="eco-badge">🌱 Social Impact</div>
            </div>

            <div class="parking-spot">
              <h5>⚡ Electric Vehicles</h5>
              <div class="parking-info">
                <span>Tip</span>
                <span>Switch to electric or hybrid vehicles for zero/low emissions</span>
              </div>
              <div class="parking-info">
                <span>CO2 Savings</span>
                <span>Up to 100% reduction (depending on energy source)</span>
              </div>
              <div class="ev-badge">⚡ Future Ready</div>
            </div>

            <div class="parking-spot">
              <h5>🚴 Active Transport</h5>
              <div class="parking-info">
                <span>Tip</span>
                <span>Cycle or walk for short distances, use bike sharing</span>
              </div>
              <div class="parking-info">
                <span>CO2 Savings</span>
                <span>100% emission-free + health benefits</span>
              </div>
              <div class="eco-badge">💪 Health Bonus</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- About Us Modal -->
  <div id="aboutModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>ℹ️ About Smart Parking Search</h3>
        <button class="close" onclick="closeModal('aboutModal')">&times;</button>
      </div>
      <div class="modal-body">
        <!-- Company Mission -->
        <div class="search-section">
          <h4>🎯 Our Mission</h4>
          <p style="color: #374151; font-size: 1.1rem; line-height: 1.7; margin-bottom: 2rem;">
            At Smart Parking Search, we're revolutionizing urban mobility by making parking intelligent, accessible, and sustainable. 
            Our mission is to reduce traffic congestion, lower carbon emissions, and enhance the quality of urban life through 
            innovative parking solutions.
          </p>

          <div class="parking-results-grid">
            <div class="parking-spot">
              <h5>🌍 Sustainability First</h5>
              <p style="color: #6b7280; margin-bottom: 1rem;">
                We believe technology should serve the environment. Our platform promotes eco-friendly transportation choices 
                and helps users reduce their carbon footprint through smart parking decisions.
              </p>
              <div class="eco-badge">🌱 Green Technology</div>
            </div>

            <div class="parking-spot">
              <h5>📊 Data-Driven Solutions</h5>
              <p style="color: #6b7280; margin-bottom: 1rem;">
                Using real-time sensor data, machine learning, and advanced analytics, we provide accurate parking information 
                that saves time and reduces urban congestion.
              </p>
              <div class="ev-badge">🤖 AI-Powered</div>
            </div>

            <div class="parking-spot">
              <h5>👥 Community Focused</h5>
              <p style="color: #6b7280; margin-bottom: 1rem;">
                We're committed to serving Melbourne's diverse communities with accessible, user-friendly solutions that 
                work for everyone, from daily commuters to occasional visitors.
              </p>
              <div class="eco-badge">🤝 Inclusive Design</div>
            </div>
          </div>
        </div>

        <!-- Our Story -->
        <div class="search-section">
          <h4>📖 Our Story</h4>
          <div class="insight-box">
            Smart Parking Search was founded in 2025 by a team of Melbourne-based developers (TP10 Tornado Team), urban planners, and sustainability advocates. 
            Frustrated by the daily struggle of finding parking in the city, we set out to create a solution that would benefit both 
            individual drivers and the broader urban environment.
          </div>

          <div style="background: rgba(255, 255, 255, 0.8); padding: 1.5rem; border-radius: 12px; border-left: 4px solid white; margin: 1rem 0;">
            <h5 style="color: #667eea; margin-bottom: 1rem;">🏆 Key Milestones</h5>
            <div style="display: grid; gap: 0.8rem; font-size: 0.95rem;">
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span><strong>2025:</strong> Company founded with initial prototype</span>
                <span style="background: #667eea; color: white; padding: 0.2rem 0.6rem; border-radius: 4px; font-size: 0.8rem;">Founded</span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span><strong>2025:</strong> Partnership with City of Melbourne for sensor data</span>
                <span style="background: #10b981; color: white; padding: 0.2rem 0.6rem; border-radius: 4px; font-size: 0.8rem;">Partnership</span>
              </div>
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <span><strong>2025:</strong> Launch of real-time parking platform</span>
                <span style="background: #f59e0b; color: white; padding: 0.2rem 0.6rem; border-radius: 4px; font-size: 0.8rem;">Launch</span>
              </div>
            </div>
          </div>
        </div>

        <!-- Our Team -->
        <div class="search-section">
          <h4>👨‍💼 Meet Our Team</h4>
          <div class="parking-results-grid">
            <div class="parking-spot">
              <h5>🧠 Natnaree Patanrasd</h5>
              <div class="parking-info">
                <span>Role</span>
                <span>Cybersecurity and Backend Developer</span>
              </div>
              <div class="parking-info">
                <span>Background</span>
                <span>Airline Business 6 years experiences</span>
              </div>
              <p style="color: #6b7280; font-size: 0.9rem; margin-top: 0.5rem;">
                Former Cabin Crew and Specialist Platform Analytics
              </p>
              <div class="ev-badge">🎓 Master of Cybersecurity</div>
            </div>

            <div class="parking-spot">
              <h5>⚡ Haojun Sun</h5>
              <div class="parking-info">
                <span>Role</span>
                <span>Backend Developer</span>
              </div>
              <div class="parking-info">
                <span>Background</span>
                <span>Software Engineering</span>
              </div>
              <p style="color: #6b7280; font-size: 0.9rem; margin-top: 0.5rem;">
                Former IT Engineer
              </p>
              <div class="ev-badge">🎓 Master of Information Technology</div>
            </div>

            <div class="parking-spot">
              <h5>🌱 Xiaoyu Yin</h5>
              <div class="parking-info">
                <span>Role</span>
                <span>Project Manager</span>
              </div>
              <div class="parking-info">
                <span>Background</span>
                <span>Project Manager</span>
              </div>
              <p style="color: #6b7280; font-size: 0.9rem; margin-top: 0.5rem;">
                
              </p>
              <div class="ev-badge">🎓 Master of Business Information System</div>
            </div>

            <div class="parking-spot">
              <h5>🧠 Jing Gao</h5>
              <div class="parking-info">
                <span>Role</span>
                <span>Project Manager</span>
              </div>
              <div class="parking-info">
                <span>Background</span>
                <span>Backend Developer</span>
              </div>
              <p style="color: #6b7280; font-size: 0.9rem; margin-top: 0.5rem;">
                
              </p>
              <div class="ev-badge">🎓 Master of Information Technology</div>
            </div>

            <div class="parking-spot">
              <h5>⚡ Chengwei Peng</h5>
              <div class="parking-info">
                <span>Role</span>
                <span>AI Engineer</span>
              </div>
              <div class="parking-info">
                <span>Background</span>
                <span></span>
              </div>
              <p style="color: #6b7280; font-size: 0.9rem; margin-top: 0.5rem;">
                
              </p>
              <div class="ev-badge">🎓 Master of Artificial Intelligent</div>
            </div>

            <div class="parking-spot">
              <h5>🌱 Yangsheng Li</h5>
              <div class="parking-info">
                <span>Role</span>
                <span>Data Engineer / QA </span>
              </div>
              <div class="parking-info">
                <span>Background</span>
                <span></span>
              </div>
              <p style="color: #6b7280; font-size: 0.9rem; margin-top: 0.5rem;">
                
              </p>
              <div class="ev-badge">🎓 Master of Data Scientist</div>
            </div>

          </div>
        </div>

        <!-- Technology Stack -->
        <div class="search-section">
          <h4>🔧 Technology & Innovation</h4>
          <p style="color: #6b7280; margin-bottom: 1.5rem;">
            Our platform leverages cutting-edge technology to deliver accurate, real-time parking information:
          </p>

          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem;">
            <div style="background: rgba(102, 126, 234, 0.05); padding: 1rem; border-radius: 8px; border-left: 3px solid #667eea;">
              <h6 style="color: #667eea; margin-bottom: 0.5rem;">📡 IoT Sensors</h6>
              <p style="font-size: 0.9rem; color: #6b7280;">Real-time parking bay occupancy detection using ultrasonic and magnetic sensors.</p>
            </div>
            <div style="background: rgba(16, 185, 129, 0.05); padding: 1rem; border-radius: 8px; border-left: 3px solid #10b981;">
              <h6 style="color: #10b981; margin-bottom: 0.5rem;">🤖 Machine Learning</h6>
              <p style="font-size: 0.9rem; color: #6b7280;">Predictive algorithms for parking availability and demand forecasting.</p>
            </div>
            <div style="background: rgba(245, 158, 11, 0.05); padding: 1rem; border-radius: 8px; border-left: 3px solid #f59e0b;">
              <h6 style="color: #f59e0b; margin-bottom: 0.5rem;">🗺️ Geospatial Analytics</h6>
              <p style="font-size: 0.9rem; color: #6b7280;">Advanced mapping and location services powered by Google Maps API.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Contact Us Modal -->
  <div id="contactModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>📞 Contact Smart Parking Search</h3>
        <button class="close" onclick="closeModal('contactModal')">&times;</button>
      </div>
      <div class="modal-body">
        <!-- Contact Information -->
        <div class="search-section">
          <h4>📧 Get in Touch</h4>
          <p style="color: #6b7280; font-size: 1.1rem; margin-bottom: 2rem;">
            We'd love to hear from you! Whether you have questions, feedback, or partnership opportunities, 
            our team is here to help.
          </p>

          <div class="parking-results-grid">
            <div class="parking-spot">
              <h5>🏢 Office Address</h5>
              <div class="parking-info">
                <span>Location</span>
                <span>Level 15, 123 Collins Street</span>
              </div>
              <div class="parking-info">
                <span>City</span>
                <span>Melbourne, VIC 3000</span>
              </div>
              <div class="parking-info">
                <span>Country</span>
                <span>Australia</span>
              </div>
              <div class="eco-badge">📍 CBD Location</div>
            </div>

            <div class="parking-spot">
              <h5>📱 Contact Details</h5>
              <div class="parking-info">
                <span>Phone</span>
                <span>+61 3 9000 1234</span>
              </div>
              <div class="parking-info">
                <span>Email</span>
                <span>hello@smartparking.com.au</span>
              </div>
              <div class="parking-info">
                <span>Support</span>
                <span>support@smartparking.com.au</span>
              </div>
              <div class="ev-badge">24/7 Support</div>
            </div>

            <div class="parking-spot">
              <h5>🕒 Business Hours</h5>
              <div class="parking-info">
                <span>Monday - Friday</span>
                <span>9:00 AM - 6:00 PM</span>
              </div>
              <div class="parking-info">
                <span>Saturday</span>
                <span>10:00 AM - 4:00 PM</span>
              </div>
              <div class="parking-info">
                <span>Sunday</span>
                <span>Closed</span>
              </div>
              <div class="eco-badge">AEST Timezone</div>
            </div>
          </div>
        </div>

        <!-- Contact Form -->
        <div class="search-section">
          <h4>✉️ Send us a Message</h4>
          <form style="max-width: 600px;">
            <div style="display: grid; gap: 1rem; margin-bottom: 1.5rem;">
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                <input type="text" placeholder="Your Name" style="padding: 1rem; border: 2px solid rgba(102, 126, 234, 0.1); border-radius: 8px; font-size: 1rem;">
                <input type="email" placeholder="Your Email" style="padding: 1rem; border: 2px solid rgba(102, 126, 234, 0.1); border-radius: 8px; font-size: 1rem;">
              </div>
              <select style="padding: 1rem; border: 2px solid rgba(102, 126, 234, 0.1); border-radius: 8px; font-size: 1rem;">
                <option>General Inquiry</option>
                <option>Technical Support</option>
                <option>Partnership Opportunity</option>
                <option>Feature Request</option>
                <option>Bug Report</option>
                <option>Media Inquiry</option>
              </select>
              <input type="text" placeholder="Subject" style="padding: 1rem; border: 2px solid rgba(102, 126, 234, 0.1); border-radius: 8px; font-size: 1rem;">
              <textarea placeholder="Your Message" rows="5" style="padding: 1rem; border: 2px solid rgba(102, 126, 234, 0.1); border-radius: 8px; font-size: 1rem; resize: vertical; font-family: inherit;"></textarea>
            </div>
            <button type="submit" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; padding: 1rem 2rem; border-radius: 8px; font-size: 1rem; font-weight: 600; cursor: pointer;">
              📧 Send Message
            </button>
          </form>
        </div>

        <!-- FAQ Section -->
        <div class="search-section">
          <h4>❓ Frequently Asked Questions</h4>
          <div style="display: grid; gap: 1rem;">
            <div style="background: rgba(255, 255, 255, 0.8); padding: 1.2rem; border-radius: 8px; border-left: 4px solid #667eea;">
              <h6 style="color: #667eea; margin-bottom: 0.5rem;">How accurate is the real-time parking data?</h6>
              <p style="color: #6b7280; font-size: 0.95rem; margin: 0;">
                Our sensor data is updated every 30 seconds and has an accuracy rate of over 95%. However, availability can change rapidly in busy areas.
              </p>
            </div>
            <div style="background: rgba(255, 255, 255, 0.8); padding: 1.2rem; border-radius: 8px; border-left: 4px solid #10b981;">
              <h6 style="color: #10b981; margin-bottom: 0.5rem;">Is the service free to use?</h6>
              <p style="color: #6b7280; font-size: 0.95rem; margin: 0;">
                Yes! Our basic parking search and eco-planning features are completely free. We may introduce premium features in the future.
              </p>
            </div>
            <div style="background: rgba(255, 255, 255, 0.8); padding: 1.2rem; border-radius: 8px; border-left: 4px solid #f59e0b;">
              <h6 style="color: #f59e0b; margin-bottom: 0.5rem;">Do you cover areas outside Melbourne?</h6>
              <p style="color: #6b7280; font-size: 0.95rem; margin: 0;">
                Currently, we focus exclusively on Melbourne and surrounding suburbs. We plan to expand to other Australian cities in 2026.
              </p>
            </div>
          </div>
        </div>

        <!-- Social Media & Links -->
        <div class="search-section">
          <h4>🌐 Connect With Us</h4>
          <div class="parking-results-grid">
            <div class="parking-spot" style="cursor: pointer;">
              <h5>📘 Facebook</h5>
              <p style="color: #6b7280;">Follow us for updates and community discussions</p>
              <div style="background: #1877f2; color: white; padding: 0.3rem 0.8rem; border-radius: 6px; font-size: 0.8rem; display: inline-block;">@SmartParkingMelb</div>
            </div>
            <div class="parking-spot" style="cursor: pointer;">
              <h5>🐦 Twitter</h5>
              <p style="color: #6b7280;">Real-time updates and parking tips</p>
              <div style="background: #1da1f2; color: white; padding: 0.3rem 0.8rem; border-radius: 6px; font-size: 0.8rem; display: inline-block;">@SmartParkingAU</div>
            </div>
            <div class="parking-spot" style="cursor: pointer;">
              <h5>💼 LinkedIn</h5>
              <p style="color: #6b7280;">Professional updates and industry insights</p>
              <div style="background: #0a66c2; color: white; padding: 0.3rem 0.8rem; border-radius: 6px; font-size: 0.8rem; display: inline-block;">Smart Parking Search</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  


<!-- Google Maps API -->
<script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDwXzBClakuchQF0zxKk0UBkPhLX--d7tg&libraries=places&callback=initMaps"></script>

<script>
 // Tab functionality
 function initTabs() {
   const tabButtons = document.querySelectorAll('.tab-button');
   const tabContents = document.querySelectorAll('.tab-content');

   tabButtons.forEach(button => {
     button.addEventListener('click', () => {
       const targetTab = button.getAttribute('data-tab');

       // Remove active class from all buttons and contents
       tabButtons.forEach(btn => btn.classList.remove('active'));
       tabContents.forEach(content => content.classList.remove('active'));

       // Add active class to clicked button and corresponding content
       button.classList.add('active');
       document.getElementById(`${targetTab}-tab`).classList.add('active');
     
    // Initialize statistics when tab is clicked
    if (targetTab === 'statistics') {
        if (!initStatistics._initialized) {
          initStatistics();
          initStatistics._initialized = true;
        } else {
          setTimeout(updateStatistics, 0);
        }
      } 
     
      });
   });
  
 }

 // Statistics Functions
 function initStatistics() {
   debugLog('Initializing statistics module');

   // Initialize year dropdown if not already done
   const yearSelect = document.getElementById('stats-year');
   if (yearSelect) {
     // Clear existing options first
     yearSelect.innerHTML = '';

     // Add year options
     STATS_DATA.years.forEach(year => {
       const option = document.createElement('option');
       option.value = year;
       option.textContent = year;
       yearSelect.appendChild(option);
     });

     // Set default to 2021
     yearSelect.value = 2021;
   }

   // Update statistics on first load
   updateStatistics();
 }

 function numberWithCommas(x) {
   return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
 }

 function carSelectionToCategory(val) {
   val = parseInt(val);
   if (val === 0) return "No motor vehicles";
   if (val === 1) return "1 motor vehicle";
   if (val === 2) return "2 motor vehicles";
   return "3 or more motor vehicles";
 }

 function computePercentile(region, year, hhcars) {
   const cat = carSelectionToCategory(hhcars);
   const order = ["No motor vehicles", "1 motor vehicle", "2 motor vehicles", "3 or more motor vehicles"];
   const counts = order.map(c => STATS_DATA.regions[region].vehicle_categories[c][year]);
   const total = counts.reduce((a, b) => a + b, 0);
   let cum = 0;
   for (let i = 0; i < order.length; i++) {
     cum += counts[i];
     if (order[i] === cat) break;
   }
   return total > 0 ? (cum / total * 100) : 0;
 }

 function drawStatsTrend(region) {
   const years = STATS_DATA.years;
   const pop = years.map(y => STATS_DATA.regions[region].pop_series[y]);
   const vp1000 = years.map(y => STATS_DATA.regions[region].vehicles_per_1000[y]);

   Plotly.newPlot('stats-chart1', [
     {
       x: years,
       y: pop.map(v => v / 1000),
       mode: 'lines+markers',
       name: 'Population (thousands)',
       yaxis: 'y1',
       line: { color: '#667eea', width: 3 },
       marker: { color: '#667eea', size: 8 }
     },
     {
       x: years,
       y: vp1000,
       mode: 'lines+markers',
       name: 'Vehicles per 1,000',
       yaxis: 'y2',
       line: { color: '#764ba2', width: 3 },
       marker: { color: '#764ba2', size: 8 }
     }
   ], {
     title: region + ' — Population & Vehicles/1,000',
     yaxis: { title: 'Population (thousands)' },
     yaxis2: { title: 'Vehicles per 1,000', overlaying: 'y', side: 'right' },
     margin: { t: 40, l: 50, r: 45, b: 40 },
     legend: { orientation: 'h', y: -0.15 },
     paper_bgcolor: 'rgba(0,0,0,0)',
     plot_bgcolor: 'rgba(0,0,0,0)'
   }, { responsive: true });
 }

 function drawStatsCategoryBar(region, year, selectedCars) {
   const cats = STATS_DATA.categories;
   const vals = cats.map(c => STATS_DATA.regions[region].vehicle_categories[c][year]);
   const colors = cats.map(c =>
           c === carSelectionToCategory(selectedCars) ?
                   'rgba(102, 126, 234, 0.9)' :
                   'rgba(200, 200, 200, 0.8)'
   );

   Plotly.newPlot('stats-chart2', [{
     x: cats,
     y: vals,
     type: 'bar',
     name: 'Households',
     marker: { color: colors }
   }], {
     title: region + ' — Household Vehicle Count (' + year + ')',
     yaxis: { title: 'Number of households' },
     margin: { t: 40, l: 50, r: 20, b: 80 },
     paper_bgcolor: 'rgba(0,0,0,0)',
     plot_bgcolor: 'rgba(0,0,0,0)'
   }, { responsive: true });
 }

function updateStatistics() {
  const region = document.getElementById('stats-region').value;
  const year   = document.getElementById('stats-year').value;
  const hhcars = parseInt(document.getElementById('stats-hhcars').value);


  const pop    = STATS_DATA.regions[region].pop_series[year];
  const vp1000 = STATS_DATA.regions[region].vehicles_per_1000[year];
  const pct    = computePercentile(region, year, hhcars); 


  document.getElementById('stats-pop').textContent    = numberWithCommas(pop);
  document.getElementById('stats-vp1000').textContent = vp1000.toFixed(1);
  document.getElementById('stats-percentile').textContent = pct.toFixed(0) + '%';


  drawStatsTrend(region);                     
  drawStatsCategoryBar(region, year, hhcars); 

  (function renderInsights(){
    const firstYear = STATS_DATA.years[0];
    const pop0 = STATS_DATA.regions[region].pop_series[firstYear];
    const pop1 = STATS_DATA.regions[region].pop_series[year];
    const veh0 = STATS_DATA.regions[region].vehicles_total[firstYear];
    const veh1 = STATS_DATA.regions[region].vehicles_total[year];

    const popChg = pop0 ? ((pop1 - pop0) / pop0 * 100).toFixed(1) : '0.0';
    const vehChg = veh0 ? ((veh1 - veh0) / veh0 * 100).toFixed(1) : '0.0';

    let trendLine = '';
    if (parseFloat(vehChg) - parseFloat(popChg) > 3) {
      trendLine = 'car ownership has outpaced population growth, which may intensify congestion.';
    } else if (parseFloat(popChg) - parseFloat(vehChg) > 3) {
      trendLine = 'population has grown faster than car ownership, which may slightly ease congestion pressure.';
    } else {
      trendLine = 'car ownership and population have grown at a similar rate, maintaining current congestion patterns.';
    }

    let youLine = '';
    if (pct >= 70) {
      youLine = `Your household is at the ${pct.toFixed(0)}th percentile — higher vehicle ownership than most households in ${region}.`;
    } else if (pct <= 30) {
      youLine = `Your household is at the ${pct.toFixed(0)}th percentile — lower vehicle ownership than most households in ${region}.`;
    } else {
      youLine = `Your household sits around the middle (the ${pct.toFixed(0)}th percentile), close to the regional norm.`;
    }

    const el = document.getElementById('stats-insights');
    if (el) {
      el.innerHTML = `
        <strong>Insights:</strong>
        In <em>${region}</em>, population grew by <em>${popChg}%</em> from <em>${firstYear}</em> to <em>${year}</em>,
        while household vehicle ownership grew by <em>${vehChg}%</em>. This suggests that ${trendLine}
        <br/>${youLine}
      `;
    }
  })();
}

 // Google Maps Configuration
 let parkingMap;
 let placesService;
 let parkingAutocomplete;
 let parkingMarkers = [];

 // Melbourne coordinates-broader area to show all suburbs
 const MELBOURNE_CENTER = { lat: -37.8136, lng: 144.9631 };
 const MELBOURNE_BOUNDS = {
   north: -37.4,   // Northern suburbs
   south: -38.2,   // Southern suburbs
   east: 145.5,    // Eastern suburbs
   west: 144.4     // Western suburbs
 };

 // Global variables
 let userTokens = null;
 let isAuthenticated = false;
 let melbourneParkingData = [];
 let restrictionsData = [];
 let greenParkingMap;
 let greenParkingAutocomplete;
 let greenParkingMarkers = [];


 // Statistics Data for Melbourne
 const STATS_DATA = {
   "years": [2001, 2006, 2011, 2016, 2021],
   "regions": {
     "City of Melbourne": {
       "pop_series": {"2001": 431549, "2006": 480345, "2011": 532351, "2016": 633471, "2021": 627671},
       "area_km2": 142.5,
       "vehicle_categories": {
         "No motor vehicles": {"2001": 7752, "2006": 12372, "2011": 17430, "2016": 28140, "2021": 32707},
         "1 motor vehicle": {"2001": 9594, "2006": 13564, "2011": 16862, "2016": 21703, "2021": 29957},
         "2 motor vehicles": {"2001": 3954, "2006": 5112, "2011": 5594, "2016": 6210, "2021": 6940},
         "3 or more motor vehicles": {"2001": 792, "2006": 917, "2011": 1099, "2016": 1238, "2021": 1318}
       },
       "vehicles_total": {"2001": 14340, "2006": 19593, "2011": 23555, "2016": 29151, "2021": 38215},
       "vehicles_per_1000": {"2001": 33.2, "2006": 40.8, "2011": 44.2, "2016": 46.0, "2021": 60.9}
     },
     "Suburb Melbourne": {
       "pop_series": {"2001": 3068700, "2006": 3280415, "2011": 3637015, "2016": 4080916, "2021": 4348486},
       "area_km2": 9850.3,
       "vehicle_categories": {
         "No motor vehicles": {"2001": 111069, "2006": 115704, "2011": 116788, "2016": 113436, "2021": 120368},
         "1 motor vehicle": {"2001": 426329, "2006": 443491, "2011": 489269, "2016": 530464, "2021": 630966},
         "2 motor vehicles": {"2001": 442744, "2006": 476241, "2011": 525263, "2016": 572511, "2021": 645910},
         "3 or more motor vehicles": {"2001": 173821, "2006": 195578, "2011": 228809, "2016": 263828, "2021": 302553}
       },
       "vehicles_total": {"2001": 1042894, "2006": 1115310, "2011": 1243341, "2016": 1366803, "2021": 1579429},
       "vehicles_per_1000": {"2001": 339.8, "2006": 340.0, "2011": 341.9, "2016": 334.9, "2021": 363.2}
     },
     "Greater Melbourne (All)": {
       "pop_series": {"2001": 3500249, "2006": 3760760, "2011": 4169366, "2016": 4714387, "2021": 4976157},
       "area_km2": 9992.8,
       "vehicle_categories": {
         "No motor vehicles": {"2001": 118821, "2006": 128076, "2011": 134218, "2016": 141576, "2021": 153075},
         "1 motor vehicle": {"2001": 435923, "2006": 457055, "2011": 506131, "2016": 552167, "2021": 660923},
         "2 motor vehicles": {"2001": 446698, "2006": 481353, "2011": 530857, "2016": 578721, "2021": 652850},
         "3 or more motor vehicles": {"2001": 174613, "2006": 196495, "2011": 229908, "2016": 265066, "2021": 303871}
       },
       "vehicles_total": {"2001": 1057234, "2006": 1134903, "2011": 1266896, "2016": 1395954, "2021": 1617644},
       "vehicles_per_1000": {"2001": 302.0, "2006": 301.8, "2011": 303.9, "2016": 296.1, "2021": 325.1}
     }
   },
   "categories": ["No motor vehicles", "1 motor vehicle", "2 motor vehicles", "3 or more motor vehicles"]
 };

 // DOM elements
 const userGreeting = document.getElementById('userGreeting');
 const logoutBtn = document.getElementById('logoutBtn');
 const parkingLocationInput = document.getElementById('parkingLocationInput');
 const searchParkingBtn = document.getElementById('searchParkingBtn');
 const parkingSearchStatus = document.getElementById('parkingSearchStatus');
 const parkingResultsSection = document.getElementById('parkingResultsSection');
 const parkingResultsGrid = document.getElementById('parkingResultsGrid');

 // Debug mode
 const DEBUG_MODE = true;

 function debugLog(message, data = null) {
   if (DEBUG_MODE) {
     console.log(`[Smart Parking Search DEBUG] ${message}`, data);
   }
 }

 // Initialize Google Maps
 async function initMaps() {
   debugLog('Initializing Google Maps');

   // Load parking data first
   await loadParkingData();

   // Initialize parking search map - zoom out to show all Melbourne
   parkingMap = new google.maps.Map(document.getElementById('parkingMap'), {
     zoom: 10,  // Zoomed out to show entire Melbourne area
     center: MELBOURNE_CENTER,
     styles: [
       {
         featureType: 'poi',
         elementType: 'labels',
         stylers: [{ visibility: 'off' }]
       }
     ]
   });

   // Initialize green parking map (similar setup)
   greenParkingMap = new google.maps.Map(document.getElementById('greenParkingMap'), {
     zoom: 10,
     center: MELBOURNE_CENTER,
     styles: [
       {
         featureType: 'poi',
         elementType: 'labels',
         stylers: [{ visibility: 'off' }]
       }
     ]
   });

   // Initialize places service
   placesService = new google.maps.places.PlacesService(parkingMap);

   // Setup autocomplete for parking search - expanded bounds for all Melbourne
   parkingAutocomplete = new google.maps.places.Autocomplete(
     parkingLocationInput,
     {
       bounds: new google.maps.LatLngBounds(
         new google.maps.LatLng(MELBOURNE_BOUNDS.south, MELBOURNE_BOUNDS.west),
         new google.maps.LatLng(MELBOURNE_BOUNDS.north, MELBOURNE_BOUNDS.east)
       ),
       strictBounds: false  // Allow searches outside bounds but prioritize Melbourne
     }
   );

   // Setup autocomplete for eco planning inputs
   const ecoTripOrigin = document.getElementById('ecoTripOrigin');
   const ecoTripDestination = document.getElementById('ecoTripDestination');
   const greenParkingLocation = document.getElementById('greenParkingLocation');

   if (ecoTripOrigin) {
     new google.maps.places.Autocomplete(ecoTripOrigin, {
       bounds: new google.maps.LatLngBounds(
         new google.maps.LatLng(MELBOURNE_BOUNDS.south, MELBOURNE_BOUNDS.west),
         new google.maps.LatLng(MELBOURNE_BOUNDS.north, MELBOURNE_BOUNDS.east)
       ),
       strictBounds: false
     });
   }

   if (ecoTripDestination) {
     new google.maps.places.Autocomplete(ecoTripDestination, {
       bounds: new google.maps.LatLngBounds(
         new google.maps.LatLng(MELBOURNE_BOUNDS.south, MELBOURNE_BOUNDS.west),
         new google.maps.LatLng(MELBOURNE_BOUNDS.north, MELBOURNE_BOUNDS.east)
       ),
       strictBounds: false
     });
   }

   if (greenParkingLocation) {
     greenParkingAutocomplete = new google.maps.places.Autocomplete(greenParkingLocation, {
       bounds: new google.maps.LatLngBounds(
         new google.maps.LatLng(MELBOURNE_BOUNDS.south, MELBOURNE_BOUNDS.west),
         new google.maps.LatLng(MELBOURNE_BOUNDS.north, MELBOURNE_BOUNDS.east)
       ),
       strictBounds: false
     });

     greenParkingAutocomplete.addListener('place_changed', onGreenParkingLocationSelected);
   }

   parkingAutocomplete.addListener('place_changed', onParkingLocationSelected);

   debugLog('Google Maps initialized successfully');

   // Initialize authentication after maps are ready
   initAuth();

   // Load real parking data for Melbourne CBD by default
   setTimeout(() => {
     if (melbourneParkingData.length > 0) {
       loadRealParkingData();
     } else {
       // If data isn't loaded yet, try again
       setTimeout(() => {
         loadRealParkingData();
       }, 2000);
     }
   }, 1000);

   // Also set the input to show Melbourne as default (broader area)
   parkingLocationInput.value = "Melbourne, VIC, Australia";
 }

 // Load parking data from S3 or local CSV file
async function loadParkingData() {
  debugLog('Starting parking data load process...');

  // S3 URLs for all three CSV files
  const PARKING_CSV_URL = 'https://smartrouteparking.s3.ap-southeast-2.amazonaws.com/on-street-parking-bay-sensors.csv';
  const SEGMENTS_CSV_URL = 'https://smartrouteparking.s3.ap-southeast-2.amazonaws.com/kerbside_segments.csv';
  const RESTRICTIONS_CSV_URL = 'https://smartrouteparking.s3.ap-southeast-2.amazonaws.com/sign-plates-located-in-each-parking-zone.csv';

  try {
    debugLog('Loading parking sensors, kerbside segments, and restrictions data...');
    
    // Load all three CSV files in parallel
    const [parkingResponse, segmentsResponse, restrictionsResponse] = await Promise.all([
      fetch(PARKING_CSV_URL, {
        method: 'GET',
        mode: 'cors',
        headers: { 'Accept': 'text/csv,text/plain,*/*' }
      }),
      fetch(SEGMENTS_CSV_URL, {
        method: 'GET',
        mode: 'cors',
        headers: { 'Accept': 'text/csv,text/plain,*/*' }
      }),
      fetch(RESTRICTIONS_CSV_URL, {
        method: 'GET',
        mode: 'cors',
        headers: { 'Accept': 'text/csv,text/plain,*/*' }
      })
    ]);

    if (parkingResponse.ok && segmentsResponse.ok && restrictionsResponse.ok) {
      const [parkingContent, segmentsContent, restrictionsContent] = await Promise.all([
        parkingResponse.text(),
        segmentsResponse.text(),
        restrictionsResponse.text()
      ]);

      if (parkingContent.length > 100 && segmentsContent.length > 100 && restrictionsContent.length > 100) {
        debugLog('SUCCESS: All three CSV files loaded from S3!');
        debugLog(`Parking data size: ${parkingContent.length} characters`);
        debugLog(`Segments data size: ${segmentsContent.length} characters`);
        debugLog(`Restrictions data size: ${restrictionsContent.length} characters`);
        
        // Parse restrictions data FIRST
        await parseRestrictionsData(restrictionsContent);
        debugLog(`Loaded ${restrictionsData.length} restriction entries`);

        // Parse the segments data to create lookup table
        const segmentsLookup = await parseKerbsideSegments(segmentsContent);
        debugLog(`Created segments lookup with ${Object.keys(segmentsLookup).length} entries`);
        
        // Then parse parking data with both lookups
        await parseCSVContent(parkingContent, segmentsLookup);
        return;
      }
    }
    
    // If one or more files failed, try with just parking and segments
    if (parkingResponse.ok && segmentsResponse.ok) {
      debugLog('WARNING: Restrictions data failed to load, continuing with parking and segments only');
      const [parkingContent, segmentsContent] = await Promise.all([
        parkingResponse.text(),
        segmentsResponse.text()
      ]);
      
      if (parkingContent.length > 100 && segmentsContent.length > 100) {
        const segmentsLookup = await parseKerbsideSegments(segmentsContent);
        await parseCSVContent(parkingContent, segmentsLookup);
        return;
      }
    }
  } catch (error) {
    debugLog('Error loading CSV files:', error);
  }
  
  showS3Instructions();
}
 // Parse kerbside segments CSV to create lookup table
 // Parse kerbside segments CSV to create lookup table
async function parseKerbsideSegments(csvContent) {
  debugLog('Parsing kerbside segments CSV...');
  
  const segmentsLookup = {};
  
  try {
    const lines = csvContent.trim().split('\n');
    if (lines.length < 2) {
      debugLog('ERROR: Segments CSV has insufficient lines:', lines.length);
      return segmentsLookup;
    }

    // Parse headers
    const headerLine = lines[0];
    const headers = parseCSVLine(headerLine);
    
    debugLog('Segments CSV Headers found:', headers);

    // Find column indices (more flexible search)
    let kerbidIndex = -1;
    let roadDescIndex = -1;
    
    headers.forEach((header, index) => {
      const lowerHeader = header.toLowerCase().trim();
      if (lowerHeader.includes('kerbid') || lowerHeader.includes('kerb_id') || lowerHeader === 'kerbsideid') {
        kerbidIndex = index;
      }
      if (lowerHeader.includes('roadsegmentdescription') || 
          lowerHeader.includes('road_segment_description') ||
          lowerHeader.includes('description') ||
          lowerHeader.includes('road_name') ||
          lowerHeader.includes('street_name')) {
        roadDescIndex = index;
      }
    });
    
    debugLog(`Column indices - kerbid: ${kerbidIndex}, roadSegmentDescription: ${roadDescIndex}`);
    debugLog('Available headers:', headers);

    if (kerbidIndex === -1 || roadDescIndex === -1) {
      debugLog('ERROR: Could not find required columns in segments CSV');
      debugLog('Looking for columns containing: kerbid, roadsegmentdescription, description');
      return segmentsLookup;
    }

    // Process each data row
    let processedRows = 0;
    let validRows = 0;

    for (let i = 1; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;

      processedRows++;
      
      const values = parseCSVLine(line);
      
      if (values.length > Math.max(kerbidIndex, roadDescIndex)) {
        const kerbid = values[kerbidIndex]?.trim();
        const roadDescription = values[roadDescIndex]?.trim();
        
        if (kerbid && roadDescription && roadDescription !== '') {
          segmentsLookup[kerbid] = roadDescription;
          validRows++;
          
          // Log first few entries for verification
          if (validRows <= 5) {
            debugLog(`Sample mapping: KerbID ${kerbid} -> "${roadDescription}"`);
          }
        }
      }
    }

    debugLog(`SUCCESS: Processed ${processedRows} segments, found ${validRows} valid kerbid-description mappings`);

  } catch (error) {
    debugLog('Error parsing segments CSV:', error);
  }

  return segmentsLookup;
}


// Helper function to parse CSV line handling quoted values
function parseCSVLine(line) {
  const values = [];
  let currentValue = '';
  let inQuotes = false;

  for (let j = 0; j < line.length; j++) {
    const char = line[j];
    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      values.push(currentValue.trim().replace(/^"|"$/g, ''));
      currentValue = '';
    } else {
      currentValue += char;
    }
  }
  values.push(currentValue.trim().replace(/^"|"$/g, ''));
  
  return values;
}

// Parse restrictions CSV to create lookup table
async function parseRestrictionsData(csvContent) {
  debugLog('Parsing restrictions CSV...');
  
  restrictionsData = [];
  
  try {
    const lines = csvContent.trim().split('\n');
    if (lines.length < 2) {
      debugLog('ERROR: Restrictions CSV has insufficient lines:', lines.length);
      return;
    }

    const headerLine = lines[0];
    const headers = parseCSVLine(headerLine);
    
    debugLog('Restrictions CSV Headers found:', headers);

    // Find column indices - more flexible search
    let zoneNumberIndex = -1;
    let restrictionDisplayIndex = -1;
    let restrictionDaysIndex = -1;
    let restrictionTimeIndex = -1;
    
    headers.forEach((header, index) => {
      const lowerHeader = header.toLowerCase().trim();
      if (lowerHeader.includes('zone_number') || lowerHeader.includes('zonenumber') || lowerHeader.includes('zone')) {
        zoneNumberIndex = index;
      }
      if (lowerHeader.includes('restriction_display') || lowerHeader.includes('restriction') || lowerHeader.includes('sign_description') || lowerHeader.includes('description')) {
        restrictionDisplayIndex = index;
      }
      if (lowerHeader.includes('restriction_days') || lowerHeader.includes('days')) {
        restrictionDaysIndex = index;
      }
      if (lowerHeader.includes('restriction_time') || lowerHeader.includes('time') || lowerHeader.includes('hours')) {
        restrictionTimeIndex = index;
      }
    });

    debugLog(`Restrictions column indices - zone: ${zoneNumberIndex}, display: ${restrictionDisplayIndex}, days: ${restrictionDaysIndex}, time: ${restrictionTimeIndex}`);

    if (zoneNumberIndex === -1 || restrictionDisplayIndex === -1) {
      debugLog('ERROR: Could not find required columns in restrictions CSV');
      debugLog('Available headers:', headers);
      return;
    }

    // Process each data row
    let validRestrictions = 0;
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;
      
      const values = parseCSVLine(line);
      
      if (values.length > Math.max(zoneNumberIndex, restrictionDisplayIndex)) {
        const zoneNumber = values[zoneNumberIndex]?.trim();
        const restrictionDisplay = values[restrictionDisplayIndex]?.trim();
        const restrictionDays = restrictionDaysIndex >= 0 ? values[restrictionDaysIndex]?.trim() : '';
        const restrictionTime = restrictionTimeIndex >= 0 ? values[restrictionTimeIndex]?.trim() : '';
        
        if (zoneNumber && restrictionDisplay) {
          restrictionsData.push({
            zone_number: parseInt(zoneNumber),
            restriction_display: restrictionDisplay,
            restriction_days: restrictionDays || 'All Days',
            restriction_time: restrictionTime || '',
            category: categorizeRestriction(restrictionDisplay)
          });
          validRestrictions++;
          
          // Log first few for verification
          if (validRestrictions <= 5) {
            debugLog(`Sample restriction: Zone ${zoneNumber} -> "${restrictionDisplay}" (${categorizeRestriction(restrictionDisplay)})`);
          }
        }
      }
    }

    debugLog(`SUCCESS: Loaded ${validRestrictions} restriction entries`);
    populateRestrictionsDropdown();

  } catch (error) {
    debugLog('Error parsing restrictions CSV:', error);
  }
}

// ADD THIS FUNCTION - completely new
function populateRestrictionsDropdown() {
  const restrictionSelect = document.getElementById('restrictionSelect');
  
  if (!restrictionsData || restrictionsData.length === 0) {
    debugLog('No restrictions data available for dropdown');
    return;
  }
  
  // Get unique restriction displays from the data
  const uniqueRestrictions = [...new Set(restrictionsData.map(r => r.restriction_display))]
    .filter(display => display && display.trim() !== '')
    .sort(); // Sort alphabetically
  
  debugLog(`Found ${uniqueRestrictions.length} unique restriction types:`, uniqueRestrictions.slice(0, 5));
  
  // Clear existing options except "All Restrictions"
  restrictionSelect.innerHTML = '<option value="all">All Restrictions</option>';
  
  // Add each unique restriction as an option
  uniqueRestrictions.forEach(restriction => {
    const option = document.createElement('option');
    option.value = restriction;
    option.textContent = restriction;
    restrictionSelect.appendChild(option);
  });
  
  debugLog(`Populated restrictions dropdown with ${uniqueRestrictions.length} real restriction options`);
}

function categorizeRestriction(restrictionText) {
  if (!restrictionText) return 'unknown';
  
  const text = restrictionText.toLowerCase();
  
  // No restriction categories
  if (text.includes('no restrictions') || text.includes('unrestricted') || 
      text.includes('no time limit') || text.includes('free parking')) {
    return 'norestriction';
  }
  
  // Loading zones
  if (text.includes('loading') || text.includes('goods vehicles') || 
      text.includes('commercial') || text.includes('delivery')) {
    return 'loading';
  }
  
  // Permit only
  if (text.includes('permit') || text.includes('resident') || 
      text.includes('authorized') || text.includes('staff only')) {
    return 'permit';
  }
  
  // Time-based restrictions - extract hours
  const hourMatch = text.match(/(\d+)\s*(hr|hour|hrs|hours)/i);
  if (hourMatch) {
    const hours = parseInt(hourMatch[1]);
    if (hours <= 2) return 'shortterm';
    if (hours <= 8) return 'mediumterm';
    return 'longterm';
  }

  // Minute-based short term
  if (text.includes('30 min') || text.includes('45 min') || text.includes('1 hour')) {
    return 'shortterm';
  }
  
  // No stopping/parking
  if (text.includes('no stopping') || text.includes('no parking') || 
      text.includes('clearway') || text.includes('bus zone')) {
    return 'norestriction'; // Actually means no parking allowed
  }
  
  return 'unknown';
}

// 4. ENHANCED: Updated getParkingRestrictions function
function getParkingRestrictions(zoneNumber) {
  if (!restrictionsData || restrictionsData.length === 0) {
    return { 
      display: 'No restrictions data available', 
      days: 'Unknown', 
      time: '',
      category: 'unknown' 
    };
  }

  // Find all restrictions for this zone (there might be multiple)
  const zoneRestrictions = restrictionsData.filter(r => r.zone_number === parseInt(zoneNumber));
  
  if (!zoneRestrictions || zoneRestrictions.length === 0) {
    return { 
      display: 'No specific restrictions found', 
      days: 'All Days', 
      time: '',
      category: 'norestriction' 
    };
  }

  // If multiple restrictions, pick the most restrictive or primary one
  const primaryRestriction = zoneRestrictions[0];

  return {
    display: primaryRestriction.restriction_display,
    days: primaryRestriction.restriction_days,
    time: primaryRestriction.restriction_time,
    category: primaryRestriction.category,
    allRestrictions: zoneRestrictions // Include all for detailed view
  };
}

 // Parse CSV content into parking data
 async function parseCSVContent(csvContent, segmentsLookup = {}) {
   debugLog('Parsing CSV content...');

   try {
     const lines = csvContent.trim().split('\n');
     if (lines.length < 2) {
       debugLog('ERROR: CSV has insufficient lines:', lines.length);
       showS3Instructions();
       return;
     }

     // Parse headers
     const headerLine = lines[0];
     const headers = [];
     let current = '';
     let inQuotes = false;

     for (let i = 0; i < headerLine.length; i++) {
       const char = headerLine[i];
       if (char === '"') {
         inQuotes = !inQuotes;
       } else if (char === ',' && !inQuotes) {
         headers.push(current.trim().replace(/"/g, ''));
         current = '';
       } else {
         current += char;
       }
     }
     headers.push(current.trim().replace(/"/g, ''));

     debugLog('CSV Headers found:', headers);

     // Verify we have the expected columns
     const requiredColumns = ['Location', 'Status_Description'];
     const missingColumns = requiredColumns.filter(col => !headers.includes(col));
     if (missingColumns.length > 0) {
       debugLog('ERROR: Missing required columns:', missingColumns);
       showS3Instructions();
       return;
     }

     melbourneParkingData = [];
     let processedRows = 0;
     let validRows = 0;

     // Process each data row with progress logging for large datasets
     const totalLines = lines.length - 1;

     for (let i = 1; i < lines.length; i++) {
       const line = lines[i].trim();
       if (!line) continue;

       processedRows++;

       // Log progress for large datasets
       if (processedRows % 5000 === 0) {
         debugLog(`Processing progress: ${processedRows}/${totalLines} rows (${Math.round(processedRows/totalLines*100)}%)`);
       }

       // Parse CSV line handling quoted values
       const values = [];
       let currentValue = '';
       let inQuotes = false;

       for (let j = 0; j < line.length; j++) {
         const char = line[j];
         if (char === '"') {
           inQuotes = !inQuotes;
         } else if (char === ',' && !inQuotes) {
           values.push(currentValue.trim().replace(/^"|"$/g, ''));
           currentValue = '';
         } else {
           currentValue += char;
         }
       }
       values.push(currentValue.trim().replace(/^"|"$/g, ''));

       // Create parking spot object
       const spot = {};
       headers.forEach((header, index) => {
         let value = values[index] || '';

         if (header === 'Zone_Number' && value) {
           spot[header] = parseInt(value);
         } else if (header === 'KerbsideID' && value) {
          spot[header] = parseInt(value);
         } else if (header === 'Location' && value) {
          const coords = value.replace(/"/g, '').split(','); 
          if (coords.length === 2) {
            spot.lat = parseFloat(coords[0].trim());
            spot.lon = parseFloat(coords[1].trim());
           }
           spot[header] = value;
         } else if (header === 'Status_Description' && value) {
           spot[header] = value.toLowerCase();
         }
       });

       spot.Latitude = spot.lat;
       spot.Longitude = spot.lon;
       
       // Use segments lookup to get better road description based on kerbid
       const kerbid = spot.KerbsideID?.toString() || spot.kerbid?.toString() || spot.Kerbid?.toString();
       if (kerbid && segmentsLookup[kerbid]) {
        spot.RoadSegmentDescription = segmentsLookup[kerbid];
        debugLog(`Using road segment: KerbID ${kerbid} -> "${segmentsLookup[kerbid]}"`);
       } else {
        spot.RoadSegmentDescription = `Parking Bay ${spot.KerbsideID || spot.bay_id || 'Unknown'} (Zone ${spot.Zone_Number || 'N/A'})`;
        if (kerbid) {
          debugLog(`No segment description found for KerbID: ${kerbid}`);
        }
       }

       spot.RoadSegmentID = spot.KerbsideID || spot.Zone_Number;
       spot.LastUpdated = spot.Lastupdated || spot.Status_Timestamp || new Date().toISOString().split('T')[0];
       spot.st_marker_id = spot.KerbsideID;
       spot.bay_id = spot.KerbsideID;


       // Validate the row has required data
       if (spot.lat && spot.lon && spot.Location &&
           !isNaN(spot.lat) && !isNaN(spot.lon) &&
           spot.lat >= -39 && spot.lat <= -37 &&
           spot.lon >= 144 && spot.lon <= 146) {
         melbourneParkingData.push(spot);
         validRows++;
       }
     }

     debugLog(`SUCCESS: Processed ${processedRows} rows, found ${validRows} valid parking spots from real Melbourne data`);

     // Sample some locations to verify data coverage
     const sampleSpots = melbourneParkingData.slice(0, 5);
     debugLog('Sample parking locations loaded:');
     sampleSpots.forEach((spot, idx) => {
       debugLog(`  ${idx + 1}. ${spot.RoadSegmentDescription}`);
     });

     // Show success message
     setTimeout(() => {
       parkingSearchStatus.innerHTML = `
         <strong>✅ Real Data Loaded!</strong><br>
         Successfully loaded ${validRows} parking spots from your CSV data via S3
       `;
       parkingSearchStatus.className = 'success';
     }, 500);

   } catch (error) {
     debugLog('Error parsing CSV content:', error);
     showS3Instructions();
   }
 }

 // Show error message if real data cannot be loaded
 function showS3Instructions() {
   debugLog('⚠️  Real CSV data could not be loaded from S3 or local file');

   // Clear any existing data
   melbourneParkingData = [];

   debugLog('No sample data created - app will only work with real CSV data');

   // Show detailed error message with troubleshooting steps
   setTimeout(() => {
     parkingSearchStatus.innerHTML = `
       <strong>❌ Unable to Load Real Parking Data from S3</strong><br><br>

       <strong>Current S3 URL:</strong><br>
       <code>https://smartrouteparking.s3.ap-southeast-2.amazonaws.com/on-street-parking-bays.csv</code><br><br>

       <strong>Common Issues & Solutions:</strong><br>
       1. <strong>CORS Policy:</strong> S3 bucket needs CORS configuration to allow web access<br>
       2. <strong>Public Access:</strong> Ensure the CSV file has public read permissions<br>
       3. <strong>File Location:</strong> Verify the file was uploaded to the correct path<br>
       4. <strong>File Format:</strong> Ensure it's a valid CSV file<br><br>

       <strong>S3 CORS Configuration Needed:</strong><br>
       <code>
       {<br>
       &nbsp;&nbsp;"AllowedOrigins": ["*"],<br>
       &nbsp;&nbsp;"AllowedMethods": ["GET"],<br>
       &nbsp;&nbsp;"AllowedHeaders": ["*"]<br>
       }
       </code><br><br>

       <strong>Check browser console (F12) for detailed error messages.</strong><br>
       <small>App requires real data - no sample data available.</small>
     `;
     parkingSearchStatus.className = 'error';

     // Hide results section since no data is available
     parkingResultsSection.style.display = 'none';
   }, 1000);
 }

 // Handle parking location selection
 function onParkingLocationSelected() {
   const place = parkingAutocomplete.getPlace();
   if (!place.geometry) {
     debugLog('No geometry found for selected place');
     return;
   }

   debugLog('Location selected:', place.name);
   parkingMap.setCenter(place.geometry.location);
   adjustMapZoomForDistance();

   // Clear previous status and show searching
   parkingSearchStatus.innerText = '🔍 Searching for parking near selected location...';
   parkingSearchStatus.className = 'info';

   // Search for nearby parking automatically
   searchNearbyParking(place.geometry.location);
 }

 // Authentication functions
 async function initAuth() {
   debugLog('Initializing authentication');

   // For demo purposes, simulate authentication
   isAuthenticated = true;
   userTokens = { accessToken: 'demo-token', idToken: 'demo-id-token' };

   const userInfo = { username: 'Demo User', email: 'demo@example.com' };

   userGreeting.innerHTML = `Welcome, <strong>${userInfo.username}</strong>`;
   logoutBtn.style.display = 'inline-block';

   debugLog('Demo authentication successful');
 }

 function logout() {
   location.reload();
 }

 // Modal functions
 function showAboutModal() {
   document.getElementById('aboutModal').style.display = 'block';
   document.body.style.overflow = 'hidden';
 }

 function showContactModal() {
   document.getElementById('contactModal').style.display = 'block';
   document.body.style.overflow = 'hidden';
 }

 function closeModal(modalId) {
   document.getElementById(modalId).style.display = 'none';
   document.body.style.overflow = 'auto';
 }

 // Close modal when clicking outside
 window.onclick = function(event) {
   const aboutModal = document.getElementById('aboutModal');
   const contactModal = document.getElementById('contactModal');
   
   if (event.target === aboutModal) {
     closeModal('aboutModal');
   }
   if (event.target === contactModal) {
     closeModal('contactModal');
   }
 }

 // Close modal with Escape key
 document.addEventListener('keydown', function(event) {
   if (event.key === 'Escape') {
     closeModal('aboutModal');
     closeModal('contactModal');
   }
 });

 logoutBtn.addEventListener('click', logout);

 // Event listeners
 searchParkingBtn.addEventListener('click', searchParking);

 parkingLocationInput.addEventListener('keypress', function(e) {
   if (e.key === 'Enter') {
     e.preventDefault();
     searchParking();
   }
 });

 document.getElementById('maxDistanceSelect').addEventListener('change', function() {
   const location = parkingLocationInput.value.trim();
   if (location) {
     debugLog('Distance filter changed, re-searching...');
     searchParking();
   } else {
    adjustMapZoomForDistance();
   }
 });

 document.getElementById('parkingTypeSelect').addEventListener('change', function() {
   if (parkingResultsSection.style.display !== 'none') {
     debugLog('Parking type filter changed, re-filtering results...');
     const location = parkingLocationInput.value.trim();
     if (location) {
       searchParking();
     }
   }
 });

 document.getElementById('availabilitySelect').addEventListener('change', function() {
   if (parkingResultsSection.style.display !== 'none') {
     debugLog('Availability filter changed, re-filtering results...');
     const location = parkingLocationInput.value.trim();
     if (location) {
       searchParking();
     }
   }
 });

  document.getElementById('restrictionSelect').addEventListener('change', function() {
   if (parkingResultsSection.style.display !== 'none') {
     debugLog('Restriction filter changed, re-filtering results...');
     const location = parkingLocationInput.value.trim();
     if (location) {
       searchParking();
     }
   }
 });

 // Eco planning event listeners
 setTimeout(() => {
   const calculateEcoBtn = document.getElementById('calculateEcoBtn');
   const searchGreenParkingBtn = document.getElementById('searchGreenParkingBtn');

   if (calculateEcoBtn) {
     calculateEcoBtn.addEventListener('click', calculateCarbonFootprint);
   }

   if (searchGreenParkingBtn) {
     searchGreenParkingBtn.addEventListener('click', searchGreenParking);
   }
 }, 1000);

 // Statistics event listeners
 setTimeout(() => {
   const statsRegion = document.getElementById('stats-region');
  const statsYear = document.getElementById('stats-year');
  const statsHhcars = document.getElementById('stats-hhcars');

  if (statsRegion) statsRegion.addEventListener('change', updateStatistics);
  if (statsYear)   statsYear.addEventListener('change', updateStatistics);
  if (statsHhcars) statsHhcars.addEventListener('change', updateStatistics);
}, 1000);

 function searchParking() {
   const location = parkingLocationInput.value.trim();

   if (!location) {
     parkingSearchStatus.innerText = '❌ Please enter a location.';
     parkingSearchStatus.className = 'error';
     return;
   }

   parkingSearchStatus.innerText = '🔍 Searching for parking spots...';
   parkingSearchStatus.className = 'info';
   searchParkingBtn.disabled = true;

   // Geocode the location first
   const geocoder = new google.maps.Geocoder();
   geocoder.geocode({ address: location }, (results, status) => {
     if (status === 'OK') {
       const searchLocation = results[0].geometry.location;
       parkingMap.setCenter(searchLocation);
       adjustMapZoomForDistance();

       searchNearbyParking(searchLocation);
     } else {
       parkingSearchStatus.innerText = '❌ Location not found.';
       parkingSearchStatus.className = 'error';
       searchParkingBtn.disabled = false;
     }
   });
 }

 // Find nearby parking spots from CSV data
 function findNearbyParkingSpots(centerLat, centerLng, radiusKm = 1) {
   if (!melbourneParkingData || melbourneParkingData.length === 0) {
     debugLog('No parking data available');
     return [];
   }

   const spots = melbourneParkingData.filter(spot => {
     if (!spot.Latitude || !spot.Longitude) return false;

     // Calculate distance using Haversine formula for better accuracy
     const R = 6371; // Earth's radius in kilometers
     const dLat = (spot.Latitude - centerLat) * Math.PI / 180;
     const dLon = (spot.Longitude - centerLng) * Math.PI / 180;
     const a =
       Math.sin(dLat/2) * Math.sin(dLat/2) +
       Math.cos(centerLat * Math.PI / 180) * Math.cos(spot.Latitude * Math.PI / 180) *
       Math.sin(dLon/2) * Math.sin(dLon/2);
     const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
     const distance = R * c; // Distance in km

     return distance <= radiusKm;
   });

   // Sort by distance and return top results
   return spots.map(spot => {
     const R = 6371;
     const dLat = (spot.Latitude - centerLat) * Math.PI / 180;
     const dLon = (spot.Longitude - centerLng) * Math.PI / 180;
     const a =
       Math.sin(dLat/2) * Math.sin(dLat/2) +
       Math.cos(centerLat * Math.PI / 180) * Math.cos(spot.Latitude * Math.PI / 180) *
       Math.sin(dLon/2) * Math.sin(dLon/2);
     const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
     const distance = R * c * 1000; // Distance in meters

     return {
       ...spot,
       distance: Math.round(distance)
     };
   }).sort((a, b) => a.distance - b.distance);
 }

 function adjustMapZoomForDistance() {
  const maxDistance = parseFloat(document.getElementById('maxDistanceSelect').value);
  let zoomLevel = 10;
  
  if (maxDistance <= 0.5) {
    zoomLevel = 17; // Very close zoom
  } else if (maxDistance <= 1) {
    zoomLevel = 16; // Close zoom
  } else if (maxDistance <= 2) {
    zoomLevel = 15; // Medium-close zoom
  } else if (maxDistance <= 5) {
    zoomLevel = 13; // Medium zoom
  } else if (maxDistance <= 10) {
    zoomLevel = 11; // Wide zoom
  } else {
    zoomLevel = 10; // Widest zoom for all Melbourne
  }

  debugLog(`Adjusting map zoom to level ${zoomLevel} for ${maxDistance}km distance`);

  if (parkingMap) {
    parkingMap.setZoom(zoomLevel);
  }
  if (greenParkingMap) {
    greenParkingMap.setZoom(zoomLevel);
  }
}

 function searchNearbyParking(location) {
  debugLog('Searching for parking near location:', location.toString());

  // Clear existing markers and results
  parkingMarkers.forEach(marker => marker.setMap(null));
  parkingMarkers = [];
  parkingResultsSection.style.display = 'none';

  const maxDistance = parseFloat(document.getElementById('maxDistanceSelect').value);

  parkingMap.setCenter(location);
  adjustMapZoomForDistance();

  // Update status
  parkingSearchStatus.innerText = '🔍 Finding parking spots nearby...';
  parkingSearchStatus.className = 'info';

  // Use CSV data to find nearby parking spots
  const nearbySpots = findNearbyParkingSpots(location.lat(), location.lng(), maxDistance);
  if (nearbySpots && nearbySpots.length > 0) {
    
    // Add status and restrictions to each spot
    const spotsWithDetails = nearbySpots.map(spot => {
      let finalStatus = 'free'; // default 
      if (spot.Status_Description) {
        if (spot.Status_Description.toLowerCase() === 'unoccupied') {
          finalStatus = 'free';
        } else if (spot.Status_Description.toLowerCase() === 'present') {
          finalStatus = 'occupied';
        } else {
          finalStatus = ['free', 'occupied', 'reserved'][Math.floor(Math.random() * 3)];
        }
      } else {
        finalStatus = ['free', 'occupied', 'reserved'][Math.floor(Math.random() * 3)];
      }

      // Get restrictions for this spot
      const restrictions = getParkingRestrictions(spot.Zone_Number);
      
      return {
        ...spot,
        status: finalStatus,
        restrictions: restrictions
      };
    });

    // Apply all filters
    let filteredSpots = spotsWithDetails;

    // Filter by parking type
    const parkingType = document.getElementById('parkingTypeSelect').value;
    if (parkingType !== 'all') {
      filteredSpots = filteredSpots.filter(spot => {
        const desc = spot.RoadSegmentDescription ? spot.RoadSegmentDescription.toLowerCase() : '';
        switch (parkingType) {
          case 'street':
            return desc.includes('street') || desc.includes('road') || desc.includes('avenue');
          case 'garage':
            return desc.includes('garage') || desc.includes('building') || desc.includes('car park');
          case 'lot':
            return desc.includes('lot') || desc.includes('park') && !desc.includes('national');
          case 'private':
            return desc.includes('private') || desc.includes('secure');
          default:
            return true;
        }
      });
    }

    // Filter by availability
    const availabilityFilter = document.getElementById('availabilitySelect').value;
    if (availabilityFilter !== 'all') {
      const statusMap = {
        'available': 'free',
        'occupied': 'occupied',
        'reserved': 'reserved'
      };
      filteredSpots = filteredSpots.filter(spot => spot.status === statusMap[availabilityFilter]);
    }

    // FIXED: Filter by restrictions
    const restrictionFilter = document.getElementById('restrictionSelect').value;
    if (restrictionFilter !== 'all') {
      debugLog(`Applying restriction filter: ${restrictionFilter}`);
      const beforeCount = filteredSpots.length;
      filteredSpots = filteredSpots.filter(spot => {
        return spot.restrictions && spot.restrictions.display === restrictionFilter;
      });
      const afterCount = filteredSpots.length;
      debugLog(`Restriction filter results: ${beforeCount} -> ${afterCount} spots`);
    }

    // Limit to top 20 results for better performance
    const topResults = filteredSpots.slice(0, 20);

    displayCSVParkingResults(topResults, location);

    // Add markers with same filters applied
    addAllParkingMarkers(filteredSpots); // Limit markers for performance

    const availabilityText = availabilityFilter !== 'all' ? ` ${availabilityFilter}` : '';
    const restrictionText = restrictionFilter !== 'all' ? ` with ${restrictionFilter} restrictions` : '';
    parkingSearchStatus.innerText = `✅ Found ${filteredSpots.length}${availabilityText} parking spots${restrictionText} nearby`;
    parkingSearchStatus.className = 'success';
    parkingResultsSection.style.display = 'block';
  } else {
    const availabilityFilter = document.getElementById('availabilitySelect').value;
    const restrictionFilter = document.getElementById('restrictionSelect').value;
    const availabilityText = availabilityFilter !== 'all' ? ` ${availabilityFilter}` : '';
    const restrictionText = restrictionFilter !== 'all' ? ` with ${restrictionFilter} restrictions` : '';
    parkingSearchStatus.innerText = `❌ No${availabilityText} parking spots${restrictionText} found in this area. Try adjusting your filters.`;
    parkingSearchStatus.className = 'error';
  }

  // Re-enable search button
  searchParkingBtn.disabled = false;
}

 function displayCSVParkingResults(spots, searchLocation) {
  // Update results count
  const availabilityFilter = document.getElementById('availabilitySelect').value;
  const restrictionFilter = document.getElementById('restrictionSelect').value;
  const filterText = availabilityFilter !== 'all' ? ` ${availabilityFilter}` : '';
  const restrictionText = restrictionFilter !== 'all' ? ` (${restrictionFilter} restrictions)` : '';
  document.getElementById('parkingResultsCount').innerText =
    `Found ${spots.length}${filterText} best parking spots${restrictionText} from Melbourne data`;

  // Create parking spot cards with restrictions
  let resultsHTML = '';
  spots.forEach((spot, index) => {
    // Extract street name for cleaner display
    const streetName = spot.RoadSegmentDescription ?
      spot.RoadSegmentDescription.split(' between')[0] : 'Parking Spot';

    // Check if this spot has real sensor data
    const hasRealStatus = spot.Status_Description && ['unoccupied', 'present'].includes(spot.Status_Description.toLowerCase());
    
    // Use real sensor status if available, otherwise use assigned status
    let finalStatus;
    if (hasRealStatus) {
       finalStatus = spot.Status_Description.toLowerCase() === 'unoccupied' ? 'free' : 'occupied';
     } else {
       finalStatus = spot.status || 'free';
     }

    // Status display text and styling
    const statusConfig = {
      free: { text: 'Available', class: 'status-free', emoji: '🟢' },
      occupied: { text: 'Occupied', class: 'status-occupied', emoji: '🔴' },
      reserved: { text: 'Reserved', class: 'status-reserved', emoji: '🟡' }
    };

    const status = statusConfig[finalStatus];

    // Restrictions display
    const restrictions = spot.restrictions || {};
    const restrictionDisplay = restrictions.display || 'No restrictions data';
    const restrictionCategory = restrictions.category || 'unknown';
    
    // Restriction category colors
    const restrictionColors = {
      'norestriction': 'rgba(16, 185, 129, 0.1); color: #059669',
      'shortterm': 'rgba(245, 158, 11, 0.1); color: #d97706',
      'mediumterm': 'rgba(59, 130, 246, 0.1); color: #2563eb',
      'longterm': 'rgba(16, 185, 129, 0.1); color: #059669',
      'permit': 'rgba(239, 68, 68, 0.1); color: #dc2626',
      'loading': 'rgba(168, 85, 247, 0.1); color: #7c3aed',
      'unknown': 'rgba(107, 114, 128, 0.1); color: #4b5563'
    };

    const restrictionStyle = restrictionColors[restrictionCategory] || restrictionColors['unknown'];

    resultsHTML += `
      <div class="parking-spot">
        <h5>
          🅿️ ${streetName}
          <span class="status-indicator ${status.class}"></span>
        </h5>
        <div class="parking-info">
          <span>Status</span>
          <span style="background: ${finalStatus === 'free' ? 'rgba(16, 185, 129, 0.1); color: #059669' : finalStatus === 'occupied' ? 'rgba(239, 68, 68, 0.1); color: #dc2626' : 'rgba(245, 158, 11, 0.1); color: #d97706'}">${status.emoji} ${status.text}</span>
        </div>
        <div class="parking-info">
          <span>Restrictions</span>
          <span style="background: ${restrictionStyle}; font-size: 0.85rem; max-width: 200px; word-wrap: break-word;">${restrictionDisplay.length > 30 ? restrictionDisplay.substring(0, 30) + '...' : restrictionDisplay}</span>
        </div>
        ${restrictions.days && restrictions.days !== 'All Days' ? `
        <div class="parking-info">
          <span>Days</span>
          <span>📅 ${restrictions.days}</span>
        </div>` : ''}
        ${restrictions.time ? `
        <div class="parking-info">
          <span>Time</span>
          <span>🕒 ${restrictions.time}</span>
        </div>` : ''}
        <div class="parking-info">
          <span>Distance</span>
          <span>📍 ${spot.distance}m away</span>
        </div>
        <div class="parking-info">
          <span>Bay ID</span>
          <span>#${spot.KerbsideID || spot.RoadSegmentID}</span>
        </div>
        <div class="parking-info">
          <span>Zone</span>
          <span>🏢 ${spot.Zone_Number || 'N/A'}</span>
        </div>         
        <div class="parking-info">
          <span>Last Updated</span>
          <span>🕒 ${spot.LastUpdated}</span>
        </div>
        ${hasRealStatus ? '<div class="eco-badge">📡 Real Sensor Data</div>' : '<div class="ev-badge">🎯 Estimated Status</div>'}
        ${restrictionCategory === 'norestriction' ? '<div class="eco-badge">✅ No Restrictions</div>' : ''}
        ${restrictionCategory === 'shortterm' ? '<div class="ev-badge">⏰ Short Term</div>' : ''}
        ${restrictionCategory === 'longterm' ? '<div class="eco-badge">🅿️ Long Term</div>' : ''}
        ${restrictionCategory === 'permit' ? '<div class="ev-badge" style="background: linear-gradient(135deg, #ef4444, #dc2626);">🚫 Permit Required</div>' : ''}
        ${spot.KerbsideID ? '<div class="ev-badge">🏷️ Tracked Spot</div>' : ''}
        <div class="parking-actions">
          <button class="navigate-btn" onclick="navigateToParking(${spot.Latitude}, ${spot.Longitude}, '${streetName.replace(/'/g, "\\'")}')">
            🧭 Navigate
          </button>
        </div>
      </div>
    `;
  });

  parkingResultsGrid.innerHTML = resultsHTML;
}

 // Load real parking data for Melbourne (ALL areas) - ONLY real data, no samples
 function loadRealParkingData() {
  debugLog('loadRealParkingData called with restrictions support');
  parkingSearchStatus.innerText = '🔍 Loading Melbourne parking spots with restrictions data...';
  parkingSearchStatus.className = 'info';

  // Clear existing markers
  parkingMarkers.forEach(marker => marker.setMap(null));
  parkingMarkers = [];

  // Check if we have real parking data loaded
  if (!melbourneParkingData || melbourneParkingData.length === 0) {
    debugLog('ERROR: No real parking data available');
    parkingSearchStatus.innerText = '❌ No real parking data loaded. Check S3 configuration.';
    parkingSearchStatus.className = 'error';
    parkingResultsSection.style.display = 'none';
    return;
  }

  debugLog(`Processing ${melbourneParkingData.length} real parking data points with restrictions`);
  debugLog(`Restrictions data available: ${restrictionsData.length} entries`);

  // Get current filters
  const maxDistance = parseFloat(document.getElementById('maxDistanceSelect').value);
  const restrictionFilter = document.getElementById('restrictionSelect').value;

  // Process all spots with restrictions
  const allSpots = melbourneParkingData.map(spot => {
    const distance = Math.round(
      Math.sqrt(
        Math.pow((spot.Latitude - MELBOURNE_CENTER.lat) * 111000, 2) +
        Math.pow((spot.Longitude - MELBOURNE_CENTER.lng) * 111000, 2)
      )
    );
    
    // Add restrictions to each spot
    const restrictions = getParkingRestrictions(spot.Zone_Number);
    
    return { 
      ...spot, 
      distance,
      restrictions,
      status: ['free', 'occupied', 'reserved'][Math.floor(Math.random() * 3)]
    };
  }).filter(spot => spot.distance <= maxDistance * 1000); // Filter by distance

  // Apply restriction filter
  let filteredSpots = allSpots;
  if (restrictionFilter !== 'all') {
    debugLog(`Applying restriction filter: ${restrictionFilter}`);
    const beforeCount = filteredSpots.length;
    filteredSpots = allSpots.filter(spot => {
      return spot.restrictions && spot.restrictions.display === restrictionFilter;
    });
    const afterCount = filteredSpots.length;
    debugLog(`Restriction filter results: ${beforeCount} -> ${afterCount} spots`);
  }

  // Apply availability filter
  const availabilityFilter = document.getElementById('availabilitySelect').value;
  if (availabilityFilter !== 'all') {
    const statusMap = {
      'available': 'free',
      'occupied': 'occupied',
      'reserved': 'reserved'
    };
    filteredSpots = filteredSpots.filter(spot => spot.status === statusMap[availabilityFilter]);
  }

  // Group for analysis
  const spotsByDistance = {
    cbd: filteredSpots.filter(s => s.distance <= 2000),
    inner: filteredSpots.filter(s => s.distance > 2000 && s.distance <= 10000),
    outer: filteredSpots.filter(s => s.distance > 10000)
  };

  debugLog(`Filtered parking with restrictions (${maxDistance}km, ${restrictionFilter}): CBD (${spotsByDistance.cbd.length}), Inner (${spotsByDistance.inner.length}), Outer (${spotsByDistance.outer.length})`);

  // Sample spots for display
  const displaySpots = [];
  displaySpots.push(...spotsByDistance.cbd.slice(0, 40));
  displaySpots.push(...spotsByDistance.inner.slice(0, 40));
  displaySpots.push(...spotsByDistance.outer.slice(0, 20));

  const sortedSpots = displaySpots.sort((a, b) => a.distance - b.distance);

  if (sortedSpots && sortedSpots.length > 0) {
    displayCSVParkingResults(sortedSpots, { lat: () => MELBOURNE_CENTER.lat, lng: () => MELBOURNE_CENTER.lng });

    const availabilityText = availabilityFilter !== 'all' ? ` ${availabilityFilter}` : '';
    const restrictionText = restrictionFilter !== 'all' ? ` with ${restrictionFilter} restrictions` : '';
    parkingSearchStatus.innerText = `✅ Loaded ${filteredSpots.length}${availabilityText} Melbourne parking spots${restrictionText} within ${maxDistance}km`;
    parkingSearchStatus.className = 'success';
    parkingResultsSection.style.display = 'block';

    // Add markers with restrictions info
    const allMarkerSpots = [];
    for (let i = 0; i < spotsByDistance.cbd.length; i += 10) {
      allMarkerSpots.push(spotsByDistance.cbd[i]);
    }
    for (let i = 0; i < spotsByDistance.inner.length; i += 20) {
      allMarkerSpots.push(spotsByDistance.inner[i]);
    }
    for (let i = 0; i < spotsByDistance.outer.length; i += 50) {
      allMarkerSpots.push(spotsByDistance.outer[i]);
    }

    addAllParkingMarkers(allMarkerSpots);
    debugLog(`Added ${allMarkerSpots.length} markers with restrictions data`);

    adjustMapZoomForDistance();

  } else {
    const availabilityText = availabilityFilter !== 'all' ? ` ${availabilityFilter}` : '';
    const restrictionText = restrictionFilter !== 'all' ? ` with ${restrictionFilter} restrictions` : '';
    parkingSearchStatus.innerText = `❌ No${availabilityText} parking spots${restrictionText} available within ${maxDistance}km.`;
    parkingSearchStatus.className = 'error';
    parkingResultsSection.style.display = 'none';
  }
}

 // Add function to display many markers on map
 function addAllParkingMarkers(spots) {
   spots.forEach((spot, index) => {
     // Use the status from the spot (added during search)
     let finalStatus;
     if (spot.Status_Description && ['unoccupied', 'present'].includes(spot.Status_Description.toLowerCase())) {
      finalStatus = spot.Status_Description.toLowerCase() === 'unoccupied' ? 'free' : 'occupied';
     } else {
      finalStatus = spot.status || 'free';
     }

      const hasRealStatus = spot.Status_Description && ['unoccupied', 'present'].includes(spot.Status_Description.toLowerCase());

     // Marker colors based on status
     const markerColors = {
       free: '#10b981',      // Green
       occupied: '#ef4444',   // Red
       reserved: '#f59e0b'    // Amber/Orange
     };

     const markerColor = markerColors[finalStatus];

     const marker = new google.maps.Marker({
       position: { lat: spot.Latitude, lng: spot.Longitude },
       map: parkingMap,
       title: `${spot.RoadSegmentDescription} (${spot.distance}m away)`,
       icon: {
         url: 'data:image/svg+xml;base64,' + btoa(`
           <svg width="24" height="24" xmlns="http://www.w3.org/2000/svg">
             <circle cx="12" cy="12" r="10" fill="${markerColor}" stroke="#ffffff" stroke-width="2"/>
             <circle cx="12" cy="12" r="6" fill="${markerColor}" opacity="0.8"/>
             <text x="12" y="16" text-anchor="middle" fill="white" font-size="10" font-family="Arial" font-weight="bold">P</text>
           </svg>
         `),
         scaledSize: new google.maps.Size(24, 24),
         anchor: new google.maps.Point(12, 12)
       }
     });

     // Status display configuration
     const statusConfig = {
       free: { text: 'Available', emoji: '🟢', color: '#10b981' },
       occupied: { text: 'Occupied', emoji: '🔴', color: '#ef4444' },
       reserved: { text: 'Reserved', emoji: '🟡', color: '#f59e0b' }
     };

     const status = statusConfig[finalStatus];



     // Enhanced info window with status - more compact design
     const spotName = spot.RoadSegmentDescription.length > 25 ? spot.RoadSegmentDescription.substring(0, 25) + '...' : spot.RoadSegmentDescription;
     const infoWindow = new google.maps.InfoWindow({
       content: `
         <div style="padding: 10px; width: 240px; max-width: 240px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.3;">
           <h5 style="margin: 0 0 8px 0; color: #1a202c; font-size: 1rem; font-weight: 700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">🅿️ ${spotName}</h5>

           <div style="background: ${status.color}15; border-left: 3px solid ${status.color}; padding: 6px 8px; border-radius: 6px; margin-bottom: 8px;">
             <div style="display: flex; align-items: center; gap: 4px;">
               <span style="font-size: 12px;">${status.emoji}</span>
               <strong style="color: ${status.color}; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.3px;">${status.text}</strong>
               ${hasRealStatus ? '<span style="background: #10b981; color: white; padding: 1px 4px; border-radius: 3px; font-size: 0.6rem; margin-left: 4px;">LIVE</span>' : ''}
             </div>
           </div>

           <div style="display: grid; gap: 4px; font-size: 0.8rem; margin-bottom: 8px;">
             <div style="display: flex; justify-content: space-between;">
               <span style="color: #6b7280; font-weight: 500;">Distance:</span>
               <span style="font-weight: 600; color: #1a202c;">📍 ${spot.distance}m</span>
             </div>
             <div style="display: flex; justify-content: space-between;">
               <span style="color: #6b7280; font-weight: 500;">Bay:</span>
               <span style="font-weight: 600; color: #1a202c;">#${spot.KerbsideID || spot.RoadSegmentID}</span>
             </div>
             <div style="display: flex; justify-content: space-between;">
               <span style="color: #6b7280; font-weight: 500;">Zone:</span>
               <span style="font-weight: 600; color: #1a202c;">${spot.Zone_Number || 'N/A'}</span>
             </div>
           </div>
           <button onclick="navigateToParking(${spot.Latitude}, ${spot.Longitude}, '${spot.RoadSegmentDescription.replace(/'/g, "\\'")}'); google.maps.event.trigger(arguments[0], 'closeclick');" 
                   style="width: 100%; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; padding: 6px 12px; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.8rem; transition: all 0.3s ease;"
                   onmouseover="this.style.background='linear-gradient(135deg, #059669, #047857)'"
                   onmouseout="this.style.background='linear-gradient(135deg, #10b981, #059669)'">
             🧭 Navigate
           </button>
         </div>
       `
     });

     marker.addListener('click', () => {
       // Close other info windows
       parkingMarkers.forEach(m => {
         if (m.infoWindow) {
           m.infoWindow.close();
         }
       });
       infoWindow.open(parkingMap, marker);
     });

     marker.infoWindow = infoWindow;
     parkingMarkers.push(marker);
   });

   debugLog(`Added ${spots.length} parking markers to map with status colors`);
 }

 // Navigation function to open Google Maps with directions
 function navigateToParking(lat, lng, name) {
   debugLog('Opening navigation to parking spot', { lat, lng, name });

   // Create Google Maps URL for navigation
   const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&destination_name=${encodeURIComponent(name)}`;

   // Open in new tab/window
   window.open(googleMapsUrl, '_blank');
 }

 // ECO PLANNING FUNCTIONS
  // Calculate carbon footprint
  function calculateCarbonFootprint() {
    const origin = document.getElementById('ecoTripOrigin').value.trim();
    const destination = document.getElementById('ecoTripDestination').value.trim();
    const transportMode = document.getElementById('transportModeSelect').value;
    const carType = document.getElementById('carTypeSelect').value;
    const frequency = document.getElementById('tripFrequencySelect').value;
    const statusEl = document.getElementById('ecoCalculationStatus');
    const resultsSection = document.getElementById('ecoResultsSection');
    const resultsGrid = document.getElementById('ecoComparisonGrid');

    if (!origin || !destination) {
      statusEl.innerText = '❌ Please enter both origin and destination.';
      statusEl.className = 'error';
      return;
    }

    statusEl.innerText = '🔍 Calculating environmental impact...';
    statusEl.className = 'info';

    // First try to geocode both locations to get coordinates
    const geocoder = new google.maps.Geocoder();

    Promise.all([
      new Promise((resolve, reject) => {
        geocoder.geocode({ address: origin }, (results, status) => {
          if (status === 'OK') resolve(results[0]);
          else reject(new Error('Origin not found'));
        });
      }),
      new Promise((resolve, reject) => {
        geocoder.geocode({ address: destination }, (results, status) => {
          if (status === 'OK') resolve(results[0]);
          else reject(new Error('Destination not found'));
        });
      })
    ]).then(([originResult, destResult]) => {
      debugLog('Geocoding successful for both locations');

      // Calculate distance using haversine formula as fallback
      const originLatLng = originResult.geometry.location;
      const destLatLng = destResult.geometry.location;

      const distance = calculateDistanceKm(
        originLatLng.lat(),
        originLatLng.lng(),
        destLatLng.lat(),
        destLatLng.lng()
      );

      debugLog(`Calculated distance: ${distance}km`);

      // Estimate duration based on distance (rough estimate)
      const estimatedDuration = Math.round(distance * 1.5); // Assume ~40km/h average in Melbourne
      const durationText = `${estimatedDuration} mins (estimated)`;

      // Use Google Maps Distance Matrix for more accurate data, with fallback
      const service = new google.maps.DistanceMatrixService();
      service.getDistanceMatrix({
        origins: [originResult.formatted_address],
        destinations: [destResult.formatted_address],
        travelMode: google.maps.TravelMode.DRIVING,
        unitSystem: google.maps.UnitSystem.METRIC,
        avoidHighways: false,
        avoidTolls: false
      }, function(response, status) {
        let finalDistance = distance;
        let finalDuration = durationText;

        if (status === 'OK' && response.rows[0].elements[0].status === 'OK') {
          // Use Google Maps data if available
          finalDistance = response.rows[0].elements[0].distance.value / 1000;
          finalDuration = response.rows[0].elements[0].duration.text;
          debugLog('Using Google Maps distance data');
        } else {
          debugLog('Using fallback distance calculation');
        }

        // Calculate emissions for different transport modes
        const emissions = calculateEmissions(finalDistance, transportMode, carType, frequency);
        displayEmissionsResults(emissions, finalDistance, finalDuration, frequency, resultsGrid, statusEl, resultsSection);
      });

    }).catch(error => {
      debugLog('Geocoding error:', error);
      statusEl.innerText = '❌ Could not find one or both locations. Please check your addresses and try again.';
      statusEl.className = 'error';
    });
  }

 // Helper function to calculate distance between two coordinates using Haversine formula
 function calculateDistanceKm(lat1, lng1, lat2, lng2) {
   const R = 6371; // Earth's radius in kilometers
   const dLat = (lat2 - lat1) * Math.PI / 180;
   const dLng = (lng2 - lng1) * Math.PI / 180;
   const a =
     Math.sin(dLat/2) * Math.sin(dLat/2) +
     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
     Math.sin(dLng/2) * Math.sin(dLng/2);
   const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
   const distance = R * c;
   return Math.round(distance * 10) / 10; // Round to 1 decimal place
 }


 // Calculate emissions based on distance and transport mode
 function calculateEmissions(distance, mode, carType, frequency) {
   // CO2 emissions in kg per km (approximate values)
   const emissionFactors = {
     car: {
       petrol: 0.19,      // kg CO2 per km
       diesel: 0.17,
       hybrid: 0.10,
       electric: 0.05     // Depends on grid energy mix
     },
     public: 0.06,        // Average for Melbourne public transport
     bike: 0.0,
     walk: 0.0,
     carpool: 0.095       // Half of petrol car (assuming 2 people)
   };

   // Frequency multipliers (trips per year)
   const frequencyMultipliers = {
     daily: 250,    // Work days per year (5 days × 50 weeks)
     weekly: 52,
     monthly: 12,
     once: 1
   };

   let emissionFactor;
   if (mode === 'car') {
     emissionFactor = emissionFactors.car[carType];
   } else {
     emissionFactor = emissionFactors[mode];
   }

   const singleTripEmissions = distance * emissionFactor * 2; // Round trip
   const annualEmissions = singleTripEmissions * frequencyMultipliers[frequency];

   // Calculate costs (approximate)
   const fuelCostPerKm = 0.12; // AUD per km
   const singleTripCost = mode === 'car' ? (distance * 2 * fuelCostPerKm) :
                         mode === 'public' ? 4.50 : 0; // Average PT fare
   const annualCost = singleTripCost * frequencyMultipliers[frequency];

   return {
     singleTrip: singleTripEmissions,
     annual: annualEmissions,
     singleTripCost,
     annualCost,
     distance,
     mode,
     carType,
     frequency
   };
 }

 // Display emissions calculation results
 function displayEmissionsResults(emissions, distance, duration, frequency, resultsGrid, statusEl, resultsSection) {
   // Generate comparison with other transport modes
   const modes = ['car', 'public', 'carpool', 'bike'];
   const carTypes = ['petrol', 'hybrid', 'electric'];

   let comparisons = [];

   modes.forEach(mode => {
     if (mode === 'car') {
       carTypes.forEach(carType => {
         const comparison = calculateEmissions(distance, mode, carType, frequency);
         comparison.label = `🚗 ${carType.charAt(0).toUpperCase() + carType.slice(1)} Car`;
         comparison.icon = mode === 'car' && carType === 'electric' ? '⚡' : '🚗';
         comparisons.push(comparison);
       });
     } else {
       const comparison = calculateEmissions(distance, mode, 'petrol', frequency);
       const labels = {
         public: '🚊 Public Transport',
         carpool: '👥 Carpool',
         bike: '🚴 Cycling',
         walk: '🚶 Walking'
       };
       comparison.label = labels[mode];
       comparison.icon = mode === 'public' ? '🚊' : mode === 'carpool' ? '👥' : mode === 'bike' ? '🚴' : '🚶';
       comparisons.push(comparison);
     }
   });

   // Sort by annual emissions (lowest first)
   comparisons.sort((a, b) => a.annual - b.annual);

   let resultsHTML = '';

   comparisons.forEach((comp, index) => {
     const isCurrentChoice = comp.mode === emissions.mode &&
                            (comp.mode !== 'car' || comp.carType === emissions.carType);
     const isGreenest = index === 0 && comp.annual > 0;
     const isCarbonNeutral = comp.annual === 0;

     const frequencyText = {
       daily: 'per work day',
       weekly: 'per week',
       monthly: 'per month',
       once: 'one-time'
     };

     resultsHTML += `
       <div class="parking-spot ${isCurrentChoice ? 'current-choice' : ''}" style="${isCurrentChoice ? 'border: 2px solid #667eea;' : ''}">
         <h5>${comp.icon} ${comp.label} ${isCurrentChoice ? '(Your Choice)' : ''}</h5>

         <div class="parking-info">
           <span>Single Trip</span>
           <span>${comp.singleTrip.toFixed(2)} kg CO2</span>
         </div>

         <div class="parking-info">
           <span>Annual Impact</span>
           <span>${comp.annual.toFixed(1)} kg CO2/year</span>
         </div>

         <div class="parking-info">
           <span>Cost ${frequencyText[frequency]}</span>
           <span>$${comp.singleTripCost.toFixed(2)}</span>
         </div>

         <div class="parking-info">
           <span>Annual Cost</span>
           <span>$${comp.annualCost.toFixed(0)}</span>
         </div>

         ${isCarbonNeutral ? '<div class="eco-badge">🌱 Carbon Neutral</div>' : ''}
         ${isGreenest && !isCarbonNeutral ? '<div class="eco-badge">🏆 Lowest Emissions</div>' : ''}
         ${comp.annual > 1000 ? '<div class="ev-badge" style="background: linear-gradient(135deg, #ef4444, #dc2626);">⚠️ High Impact</div>' : ''}
       </div>
     `;
   });

   resultsGrid.innerHTML = resultsHTML;

   const frequencyText = {
     daily: 'daily commute',
     weekly: 'weekly trips',
     monthly: 'monthly trips',
     once: 'one-time trip'
   };

   statusEl.innerHTML = `✅ Environmental impact calculated for ${distance.toFixed(1)}km ${frequencyText[frequency]} (${duration} by car)`;
   statusEl.className = 'success';
   resultsSection.style.display = 'block';
 }

 // Handle green parking location selection
 function onGreenParkingLocationSelected() {
   const place = greenParkingAutocomplete.getPlace();
   if (!place.geometry) {
     debugLog('No geometry found for green parking location');
     return;
   }

   debugLog('Green parking location selected:', place.name);
   greenParkingMap.setCenter(place.geometry.location);
   greenParkingMap.setZoom(16);

   searchGreenParkingNearLocation(place.geometry.location);
 }

 // Search for green parking options
 function searchGreenParking() {
   const location = document.getElementById('greenParkingLocation').value.trim();
   const greenFilter = document.getElementById('greenFilterSelect').value;
   const statusEl = document.getElementById('greenParkingStatus');

   if (!location) {
     statusEl.innerText = '❌ Please enter a location.';
     statusEl.className = 'error';
     return;
   }

   statusEl.innerText = '🔍 Searching for eco-friendly parking options...';
   statusEl.className = 'info';

   // Geocode the location
   const geocoder = new google.maps.Geocoder();
   geocoder.geocode({ address: location }, (results, status) => {
     if (status === 'OK') {
       const searchLocation = results[0].geometry.location;
       greenParkingMap.setCenter(searchLocation);
       greenParkingMap.setZoom(16);

       searchGreenParkingNearLocation(searchLocation, greenFilter);
     } else {
       statusEl.innerText = '❌ Location not found.';
       statusEl.className = 'error';
     }
   });
 }

 // Search for green parking near location
 function searchGreenParkingNearLocation(location, filter = 'all') {
   const statusEl = document.getElementById('greenParkingStatus');
   const resultsSection = document.getElementById('greenParkingResultsSection');
   const resultsGrid = document.getElementById('greenParkingResultsGrid');
   const resultsCount = document.getElementById('greenParkingResultsCount');

   // Clear existing markers
   greenParkingMarkers.forEach(marker => marker.setMap(null));
   greenParkingMarkers = [];

   // Find nearby parking spots from real data
   const nearbySpots = findNearbyParkingSpots(location.lat(), location.lng(), 2); // 2km radius

   if (nearbySpots && nearbySpots.length > 0) {
     // Add green attributes to spots based on filter
     const greenSpots = nearbySpots.map(spot => {
       const greenScore = calculateGreenScore(spot, filter);
       return {
         ...spot,
         greenScore,
         sustainabilityFeatures: getSustainabilityFeatures(spot, filter)
       };
     }).filter(spot => spot.greenScore > 0)
       .sort((a, b) => b.greenScore - a.greenScore)
       .slice(0, 15); // Top 15 green spots

     displayGreenParkingResults(greenSpots, filter, resultsGrid, resultsCount, statusEl, resultsSection);
     addGreenParkingMarkers(greenSpots);
   } else {
     statusEl.innerText = '❌ No eco-friendly parking options found in this area.';
     statusEl.className = 'error';
     resultsSection.style.display = 'none';
   }
 }

 // Calculate green score for parking spots
 function calculateGreenScore(spot, filter) {
   let score = 0;
   const description = spot.RoadSegmentDescription ? spot.RoadSegmentDescription.toLowerCase() : '';

   // Base score for all spots
   score += 10;

   // Public transport proximity (simulated)
   if (description.includes('flinders') || description.includes('collins') ||
       description.includes('bourke') || description.includes('station')) {
     score += 30; // Near major transport hubs
   }

   // Low congestion areas
   if (description.includes('lane') || description.includes('side') ||
       !description.includes('street')) {
     score += 20; // Quieter areas
   }

   // EV charging potential (simulated based on location)
   if (description.includes('centre') || description.includes('plaza') ||
       description.includes('complex')) {
     score += 25; // Commercial areas likely to have EV charging
   }

   // Bike parking friendly areas
   if (description.includes('park') || description.includes('garden') ||
       description.includes('square')) {
     score += 15; // Areas with space for bike parking
   }

   // Apply filter-specific scoring
   if (filter === 'publictransport') {
     score = description.includes('flinders') || description.includes('collins') ||
             description.includes('bourke') || description.includes('station') ? score : 0;
   } else if (filter === 'evcharging') {
     score = description.includes('centre') || description.includes('plaza') ||
             description.includes('complex') ? score : 0;
   } else if (filter === 'bikeparking') {
     score = description.includes('park') || description.includes('garden') ||
             description.includes('square') ? score : 0;
   } else if (filter === 'lowcongestion') {
     score = description.includes('lane') || description.includes('side') ||
             !description.includes('street') ? score : 0;
   }

   return score;
 }

 // Get sustainability features for a parking spot
 function getSustainabilityFeatures(spot, filter) {
   const features = [];
   const description = spot.RoadSegmentDescription ? spot.RoadSegmentDescription.toLowerCase() : '';

   if (description.includes('flinders') || description.includes('collins') ||
       description.includes('bourke') || description.includes('station')) {
     features.push('🚊 Near Public Transport');
   }

   if (description.includes('centre') || description.includes('plaza') ||
       description.includes('complex')) {
     features.push('⚡ EV Charging Likely');
   }

   if (description.includes('park') || description.includes('garden') ||
       description.includes('square')) {
     features.push('🚴 Bike Parking Available');
   }

   if (description.includes('lane') || description.includes('side') ||
       !description.includes('street')) {
     features.push('🌱 Low Congestion Zone');
   }

   // Add some random green features for demonstration
   if (Math.random() > 0.7) {
     features.push('🌳 Tree-Lined Street');
   }

   if (Math.random() > 0.8) {
     features.push('♻️ Recycling Nearby');
   }

   return features;
 }

 // Display green parking results
 function displayGreenParkingResults(spots, filter, resultsGrid, resultsCount, statusEl, resultsSection) {
   const filterNames = {
     all: '',
     publictransport: 'near public transport',
     evcharging: 'with EV charging',
     bikeparking: 'with bike parking',
     lowcongestion: 'in low congestion areas'
   };

   resultsCount.innerText = `Found ${spots.length} eco-friendly parking spots ${filterNames[filter] || ''}`;

   let resultsHTML = '';
   spots.forEach((spot, index) => {
     const isTopChoice = index < 3;
     const greenScore = Math.round((spot.greenScore / 100) * 100);

     resultsHTML += `
       <div class="parking-spot" style="${isTopChoice ? 'border-left: 4px solid #10b981;' : ''}">
         <h5>
           🅿️ ${spot.RoadSegmentDescription.length > 30 ?
                spot.RoadSegmentDescription.substring(0, 30) + '...' :
                spot.RoadSegmentDescription}
           ${isTopChoice ? '<span style="color: #10b981; font-size: 0.8rem; margin-left: 0.5rem;">⭐ Top Choice</span>' : ''}
         </h5>

         <div class="parking-info">
           <span>Green Score</span>
           <span style="background: linear-gradient(135deg, #10b981, #059669); color: white; border-radius: 6px; padding: 0.2rem 0.6rem; font-weight: bold;">${greenScore}% 🌱</span>
         </div>

         <div class="parking-info">
           <span>Distance</span>
           <span>📍 ${spot.distance}m away</span>
         </div>

         <div class="parking-info">
           <span>Environmental Benefits</span>
           <span style="font-size: 0.85rem;">${spot.sustainabilityFeatures.slice(0, 2).join(', ')}</span>
         </div>

         <div class="parking-info">
           <span>Segment ID</span>
           <span>#${spot.RoadSegmentID}</span>
         </div>

         ${spot.sustainabilityFeatures.map(feature => `<div class="eco-badge" style="margin: 0.2rem 0.2rem 0.2rem 0;">${feature}</div>`).join('')}

         <div class="parking-actions">
           <button class="navigate-btn" onclick="navigateToParking(${spot.Latitude}, ${spot.Longitude}, '${spot.RoadSegmentDescription.replace(/'/g, "\\'")}')">
             🧭 Navigate
           </button>
         </div>
       </div>
     `;
   });

   resultsGrid.innerHTML = resultsHTML;
   statusEl.innerText = `✅ Found ${spots.length} eco-friendly parking options with sustainability features`;
   statusEl.className = 'success';
   resultsSection.style.display = 'block';
 }

 // Add green parking markers to map
 function addGreenParkingMarkers(spots) {
   spots.forEach((spot, index) => {
     const isTopChoice = index < 3;
     const markerColor = isTopChoice ? '#10b981' : '#22c55e'; // Different greens for top choices

     const marker = new google.maps.Marker({
       position: { lat: spot.Latitude, lng: spot.Longitude },
       map: greenParkingMap,
       title: `${spot.RoadSegmentDescription} - Green Score: ${Math.round((spot.greenScore / 100) * 100)}%`,
       icon: {
        url: 'data:image/svg+xml;base64,' + btoa(`
          <svg width="32" height="40" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 40">
            <!-- Pin shape -->
            <path d="M16 2C9.373 2 4 7.373 4 14c0 7.5 12 22 12 22s12-14.5 12-22c0-6.627-5.373-12-12-12z" 
                  fill="${markerColor}" stroke="#ffffff" stroke-width="2"/>
            <!-- Inner circle -->
            <circle cx="16" cy="14" r="8" fill="#ffffff" opacity="0.9"/>
            <!-- Green leaf emoji - using Unicode -->
            <text x="16" y="18" text-anchor="middle" fill="${markerColor}" font-size="12" font-family="Arial">🌱</text>
            ${isTopChoice ? `<circle cx="26" cy="8" r="6" fill="#ffd700" stroke="#ffffff" stroke-width="1"/>
                            <text x="26" y="12" text-anchor="middle" fill="#000" font-size="8" font-weight="bold">★</text>` : ''}
          </svg>
        `),
        scaledSize: new google.maps.Size(32, 40),
        anchor: new google.maps.Point(16, 40),
        zIndex: isTopChoice ? 1000 : 500
       }
     });

     const greenScore = Math.round((spot.greenScore / 100) * 100);
     const infoWindow = new google.maps.InfoWindow({
       content: `
         <div style="padding: 12px; max-width: 300px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
           <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
             <h5 style="margin: 0; color: #1a202c; font-size: 1.1rem; font-weight: 700;">🅿️ ${spot.RoadSegmentDescription.length > 35 ? spot.RoadSegmentDescription.substring(0, 35) + '...' : spot.RoadSegmentDescription}</h5>
           </div>

            <div style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 8px 12px; border-radius: 8px; margin-bottom: 12px; text-align: center;">
              <div style="font-size: 1.1rem; font-weight: bold;">🌱 Green Score: ${greenScore}%</div>
            </div>

            <div style="display: grid; gap: 6px; font-size: 0.85rem; margin-bottom: 10px;">
              <div style="display: flex; justify-content: space-between;">
                <span style="color: #6b7280; font-weight: 600;">Distance:</span>
                <span style="font-weight: 700; color: #1a202c;">📍 ${spot.distance}m</span>
              </div>
              <div style="display: flex; justify-content: space-between;">
                <span style="color: #6b7280; font-weight: 600;">Segment ID:</span>
                <span style="font-weight: 700; color: #1a202c;">#${spot.RoadSegmentID}</span>
              </div>
            </div>

            <div style="font-size: 0.8rem; color: #10b981; font-weight: 600; margin-bottom: 8px;">Sustainability Features:</div>
            <div style="display: flex; flex-wrap: wrap; gap: 4px;">
              ${spot.sustainabilityFeatures.map(feature =>
                `<span style="background: rgba(16, 185, 129, 0.1); color: #059669; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem;">${feature}</span>`
              ).join('')}
            </div>
          </div>
        `
      });

      marker.addListener('click', () => {
        // Close other info windows
        greenParkingMarkers.forEach(m => {
          if (m.infoWindow) {
            m.infoWindow.close();
          }
        });
        infoWindow.open(greenParkingMap, marker);
      });

      marker.infoWindow = infoWindow;
      greenParkingMarkers.push(marker);
    });

    debugLog(`Added ${spots.length} green parking markers to map`);
  }

  // Error handling for Google Maps API
  window.gm_authFailure = function() {
    debugLog('Google Maps API authentication failed');
    document.getElementById('parkingMap').innerHTML =
      '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f5f5f5; color: #666;"><p>⚠️ Google Maps API key required. Please add your API key to enable maps.</p></div>';
  };

  // Initialize app when page loads
  document.addEventListener('DOMContentLoaded', function() {
    debugLog('Smart Parking Search app initialized');

    // Initialize tabs
    initTabs();

    // If Google Maps fails to load, show fallback
    setTimeout(() => {
      if (typeof google === 'undefined') {
        debugLog('Google Maps API not loaded, showing fallback');
        document.getElementById('parkingMap').innerHTML =
          '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f5f5f5; color: #666; flex-direction: column;"><p>🗺️ Parking Map</p><p style="font-size: 0.9rem; margin-top: 0.5rem;">Add your Google Maps API key to enable full functionality</p></div>';

        // Still initialize auth for demo
        initAuth();
      }
    }, 3000);
  });
  </script>
  </body>
  </html>