<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Smart Parking Search - Intelligent Parking Solutions</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
    }

    .header {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: bold;
      color: #667eea;
    }

    .user-section {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .user-greeting {
      font-weight: 500;
    }

    .logout-btn {
      background: #ff6b6b;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .logout-btn:hover {
      background: #ff5252;
      transform: translateY(-1px);
    }

    .main-container {
      max-width: 1400px;
      margin: 2rem auto;
      padding: 0 2rem;
    }

    .main-content {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 2rem;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .search-section {
      margin-bottom: 2rem;
    }

    .search-input-group {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }

    input[type="text"], select {
      flex: 1;
      min-width: 200px;
      padding: 1rem;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      font-size: 1rem;
      transition: all 0.3s ease;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    button {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 1rem 2rem;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      min-width: fit-content;
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .map-container {
      width: 100%;
      height: 400px;
      border-radius: 12px;
      overflow: hidden;
      margin: 1rem 0;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .parking-filters {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      margin: 1rem 0;
    }

    .parking-filters label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 500;
    }

    .info, .error, .success {
      padding: 1rem;
      border-radius: 12px;
      margin: 1rem 0;
      font-weight: 500;
    }

    .info {
      background: rgba(33, 150, 243, 0.1);
      color: #1976d2;
      border-left: 4px solid #2196f3;
    }

    .error {
      background: rgba(244, 67, 54, 0.1);
      color: #d32f2f;
      border-left: 4px solid #f44336;
    }

    .success {
      background: rgba(76, 175, 80, 0.1);
      color: #388e3c;
      border-left: 4px solid #4caf50;
    }

    .results-section {
      margin-top: 2rem;
    }

    .parking-results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1.5rem;
      margin-top: 1rem;
    }

    .parking-spot {
      background: white;
      padding: 1.5rem;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      border: 1px solid #e0e0e0;
    }

    .parking-spot:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    .parking-spot h5 {
      color: #667eea;
      margin-bottom: 1rem;
    }

    .parking-info {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .parking-info span:first-child {
      font-weight: 500;
      color: #666;
    }
    
    .parking-info span:last-child {
      font-weight: 600;
    }

    .eco-badge, .ev-badge {
      display: inline-block;
      background: #4caf50;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 6px;
      font-size: 0.8rem;
      margin: 0.25rem 0.25rem 0.25rem 0;
    }
    
    .ev-badge {
      background: #2196f3;
    }

    .parking-actions {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .navigate-btn {
      flex: 1;
      background: #4caf50;
      font-size: 0.9rem;
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .navigate-btn:hover {
      background: #388e3c;
    }

    @media (max-width: 768px) {
      .header {
        padding: 1rem;
        flex-direction: column;
        gap: 1rem;
      }

      .main-container {
        padding: 0 1rem;
      }

      .search-input-group {
        flex-direction: column;
      }

      .parking-results-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <div class="logo">üÖøÔ∏è Smart Parking Search</div>
    <div class="user-section">
      <div id="userGreeting" class="user-greeting">Loading...</div>
      <button id="logoutBtn" class="logout-btn" style="display: none;">Logout</button>
    </div>
  </header>

  <!-- Main Container -->
  <div class="main-container">
    <!-- Main Content -->
    <div class="main-content">
      <h3>üÖøÔ∏è Find Parking Spots</h3>
      
      <!-- Search Section -->
      <div class="search-section">
        <h4>Search for Parking</h4>
        <div class="search-input-group">
          <input type="text" id="parkingLocationInput" placeholder="Enter location or address" />
          <select id="parkingTypeSelect">
            <option value="all">All Types</option>
            <option value="street">Street Parking</option>
            <option value="garage">Parking Garage</option>
            <option value="lot">Parking Lot</option>
            <option value="private">Private Parking</option>
          </select>
          <button id="searchParkingBtn">Search Parking</button>
        </div>
        
        <div class="parking-filters">
          <label>Max Distance: 
            <select id="maxDistanceSelect">
              <option value="0.5">0.5 km</option>
              <option value="1">1 km</option>
              <option value="2" selected>2 km</option>
              <option value="5">5 km</option>
              <option value="10">10 km</option>
              <option value="20">20 km (All Melbourne)</option>
            </select>
          </label>
          
          <label>Price Range: 
            <select id="priceRangeSelect">
              <option value="all">Any Price</option>
              <option value="free">Free</option>
              <option value="low">$0-$5/hour</option>
              <option value="medium">$5-$15/hour</option>
              <option value="high">$15+/hour</option>
            </select>
          </label>
        </div>
        
        <div id="parkingSearchStatus" class="info">Ready to search for parking spots across all Melbourne areas</div>
        
        <!-- Google Map for Parking Search -->
        <div id="parkingMap" class="map-container"></div>
      </div>

      <!-- Parking Results Section -->
      <div id="parkingResultsSection" class="results-section" style="display: none;">
        <h4>Available Parking Spots</h4>
        <div id="parkingResultsCount" class="results-count"></div>
        <div id="parkingResultsGrid" class="parking-results-grid"></div>
      </div>
    </div>
  </div>

  <!-- Google Maps API -->
  <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDwXzBClakuchQF0zxKk0UBkPhLX--d7tg&libraries=places&callback=initMaps"></script>

  <script>
    // Google Maps Configuration
    let parkingMap;
    let placesService;
    let parkingAutocomplete;
    let parkingMarkers = [];

    // Melbourne coordinates - broader area to show all suburbs
    const MELBOURNE_CENTER = { lat: -37.8136, lng: 144.9631 };
    const MELBOURNE_BOUNDS = {
      north: -37.4,   // Northern suburbs
      south: -38.2,   // Southern suburbs  
      east: 145.5,    // Eastern suburbs
      west: 144.4     // Western suburbs
    };

    // Global variables
    let userTokens = null;
    let isAuthenticated = false;
    let melbourneParkingData = [];

    // DOM elements
    const userGreeting = document.getElementById('userGreeting');
    const logoutBtn = document.getElementById('logoutBtn');
    const parkingLocationInput = document.getElementById('parkingLocationInput');
    const searchParkingBtn = document.getElementById('searchParkingBtn');
    const parkingSearchStatus = document.getElementById('parkingSearchStatus');
    const parkingResultsSection = document.getElementById('parkingResultsSection');
    const parkingResultsGrid = document.getElementById('parkingResultsGrid');

    // Debug mode
    const DEBUG_MODE = true;

    function debugLog(message, data = null) {
      if (DEBUG_MODE) {
        console.log(`[Smart Parking Search DEBUG] ${message}`, data);
      }
    }

    // Initialize Google Maps
    async function initMaps() {
      debugLog('Initializing Google Maps');
      
      // Load parking data first
      await loadParkingData();
      
      // Initialize parking search map - zoom out to show all Melbourne
      parkingMap = new google.maps.Map(document.getElementById('parkingMap'), {
        zoom: 10,  // Zoomed out to show entire Melbourne area
        center: MELBOURNE_CENTER,
        styles: [
          {
            featureType: 'poi',
            elementType: 'labels',
            stylers: [{ visibility: 'off' }]
          }
        ]
      });

      // Initialize places service
      placesService = new google.maps.places.PlacesService(parkingMap);

      // Setup autocomplete for parking search - expanded bounds for all Melbourne
      parkingAutocomplete = new google.maps.places.Autocomplete(
        parkingLocationInput,
        {
          bounds: new google.maps.LatLngBounds(
            new google.maps.LatLng(MELBOURNE_BOUNDS.south, MELBOURNE_BOUNDS.west),
            new google.maps.LatLng(MELBOURNE_BOUNDS.north, MELBOURNE_BOUNDS.east)
          ),
          strictBounds: false  // Allow searches outside bounds but prioritize Melbourne
        }
      );

      parkingAutocomplete.addListener('place_changed', onParkingLocationSelected);

      debugLog('Google Maps initialized successfully');
      
      // Initialize authentication after maps are ready
      initAuth();
      
      // Load real parking data for Melbourne CBD by default
      setTimeout(() => {
        if (melbourneParkingData.length > 0) {
          loadRealParkingData();
        } else {
          // If data isn't loaded yet, try again
          setTimeout(() => {
            loadRealParkingData();
          }, 2000);
        }
      }, 1000);
      
      // Also set the input to show Melbourne as default (broader area)
      parkingLocationInput.value = "Melbourne, VIC, Australia";
    }

    // Load parking data from S3 or local CSV file
    async function loadParkingData() {
      debugLog('Starting parking data load process...');
      
      // S3 URL for the CSV file - your actual S3 URL
      const S3_CSV_URL = 'https://smartrouteparking.s3.ap-southeast-2.amazonaws.com/on-street-parking-bays.csv';
      // You can also use other cloud storage services:
      // const S3_CSV_URL = 'https://your-bucket.s3.ap-southeast-2.amazonaws.com/parking-data.csv';
      
      // Try S3 first, then local file, then fallback to sample data
      
      // Method 1: Try loading from S3
      try {
        debugLog('Attempting to load CSV from S3:', S3_CSV_URL);
        const response = await fetch(S3_CSV_URL, {
          method: 'GET',
          mode: 'cors', // Enable CORS
          headers: {
            'Accept': 'text/csv,text/plain,*/*'
          }
        });
        
        debugLog(`S3 Response status: ${response.status} ${response.statusText}`);
        debugLog(`S3 Response headers:`, Object.fromEntries(response.headers.entries()));
        
        if (response.ok) {
          const csvContent = await response.text();
          debugLog(`S3 Response content length: ${csvContent ? csvContent.length : 0} characters`);
          
          if (csvContent && csvContent.length > 100) {
            debugLog(`SUCCESS: CSV loaded from S3! Content length: ${csvContent.length} characters`);
            debugLog('First 200 characters:', csvContent.substring(0, 200));
            await parseCSVContent(csvContent);
            return;
          } else {
            debugLog('S3 response content is empty or too small');
          }
        } else {
          debugLog(`S3 fetch failed with status: ${response.status} - ${response.statusText}`);
          
          // Try to read the error response
          try {
            const errorText = await response.text();
            debugLog('S3 error response:', errorText);
          } catch (e) {
            debugLog('Could not read S3 error response');
          }
        }
      } catch (error) {
        debugLog('S3 loading error details:', {
          name: error.name,
          message: error.message,
          stack: error.stack
        });
        
        // Check for specific error types
        if (error.name === 'TypeError' && error.message.includes('CORS')) {
          debugLog('CORS ERROR: S3 bucket needs CORS configuration');
        } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
          debugLog('FETCH ERROR: Network or URL issue');
        }
      }
      
      // Method 2: Try loading from local file system (for development)
      try {
        if (window.fs && window.fs.readFile) {
          debugLog('Attempting to read local CSV file...');
          const csvContent = await window.fs.readFile('on-street-parking-bays.csv', { encoding: 'utf8' });
          
          if (csvContent && csvContent.length > 100) {
            debugLog(`SUCCESS: CSV loaded locally! Content length: ${csvContent.length} characters`);
            await parseCSVContent(csvContent);
            return;
          }
        }
      } catch (error) {
        debugLog('Local CSV file loading failed:', error.message);
      }
      
      // Method 3: Fallback to sample data with instructions
      debugLog('All loading methods failed, using sample data');
      showS3Instructions();
    }

    // Parse CSV content into parking data
    async function parseCSVContent(csvContent) {
      debugLog('Parsing CSV content...');
      
      try {
        const lines = csvContent.trim().split('\n');
        if (lines.length < 2) {
          debugLog('ERROR: CSV has insufficient lines:', lines.length);
          showS3Instructions();
          return;
        }

        // Parse headers
        const headerLine = lines[0];
        const headers = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < headerLine.length; i++) {
          const char = headerLine[i];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            headers.push(current.trim().replace(/"/g, ''));
            current = '';
          } else {
            current += char;
          }
        }
        headers.push(current.trim().replace(/"/g, ''));
        
        debugLog('CSV Headers found:', headers);

        // Verify we have the expected columns
        const requiredColumns = ['Latitude', 'Longitude', 'RoadSegmentDescription'];
        const missingColumns = requiredColumns.filter(col => !headers.includes(col));
        if (missingColumns.length > 0) {
          debugLog('ERROR: Missing required columns:', missingColumns);
          showS3Instructions();
          return;
        }

        melbourneParkingData = [];
        let processedRows = 0;
        let validRows = 0;
        
        // Process each data row with progress logging for large datasets
        const totalLines = lines.length - 1;
        
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;
          
          processedRows++;
          
          // Log progress for large datasets
          if (processedRows % 5000 === 0) {
            debugLog(`Processing progress: ${processedRows}/${totalLines} rows (${Math.round(processedRows/totalLines*100)}%)`);
          }
          
          // Parse CSV line handling quoted values
          const values = [];
          let currentValue = '';
          let inQuotes = false;
          
          for (let j = 0; j < line.length; j++) {
            const char = line[j];
            if (char === '"') {
              inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
              values.push(currentValue.trim().replace(/^"|"$/g, ''));
              currentValue = '';
            } else {
              currentValue += char;
            }
          }
          values.push(currentValue.trim().replace(/^"|"$/g, ''));
          
          // Create parking spot object
          const spot = {};
          headers.forEach((header, index) => {
            let value = values[index] || '';
            
            if (header === 'RoadSegmentID' && value) {
              spot[header] = parseInt(value);
            } else if (header === 'KerbsideID' && value) {
              spot[header] = value ? parseInt(value) : null;
            } else if ((header === 'Latitude' || header === 'Longitude') && value) {
              spot[header] = parseFloat(value);
            } else {
              spot[header] = value;
            }
          });
          
          // Validate the row has required data
          if (spot.Latitude && spot.Longitude && spot.RoadSegmentDescription && 
              !isNaN(spot.Latitude) && !isNaN(spot.Longitude) &&
              spot.Latitude >= -39 && spot.Latitude <= -37 &&
              spot.Longitude >= 144 && spot.Longitude <= 146) {
            melbourneParkingData.push(spot);
            validRows++;
          }
        }
        
        debugLog(`SUCCESS: Processed ${processedRows} rows, found ${validRows} valid parking spots from real Melbourne data`);
        
        // Sample some locations to verify data coverage
        const sampleSpots = melbourneParkingData.slice(0, 5);
        debugLog('Sample parking locations loaded:');
        sampleSpots.forEach((spot, idx) => {
          debugLog(`  ${idx + 1}. ${spot.RoadSegmentDescription}`);
        });
        
        // Show success message
        setTimeout(() => {
          parkingSearchStatus.innerHTML = `
            <strong>‚úÖ Real Data Loaded!</strong><br>
            Successfully loaded ${validRows} parking spots from your CSV data via S3
          `;
          parkingSearchStatus.className = 'success';
        }, 500);
        
      } catch (error) {
        debugLog('Error parsing CSV content:', error);
        showS3Instructions();
      }
    }

    // Show error message if real data cannot be loaded
    function showS3Instructions() {
      debugLog('‚ö†Ô∏è  Real CSV data could not be loaded from S3 or local file');
      
      // Clear any existing data
      melbourneParkingData = [];
      
      debugLog('No sample data created - app will only work with real CSV data');
      
      // Show detailed error message with troubleshooting steps
      setTimeout(() => {
        parkingSearchStatus.innerHTML = `
          <strong>‚ùå Unable to Load Real Parking Data from S3</strong><br><br>
          
          <strong>Current S3 URL:</strong><br>
          <code>https://smartrouteparking.s3.ap-southeast-2.amazonaws.com/on-street-parking-bays.csv</code><br><br>
          
          <strong>Common Issues & Solutions:</strong><br>
          1. <strong>CORS Policy:</strong> S3 bucket needs CORS configuration to allow web access<br>
          2. <strong>Public Access:</strong> Ensure the CSV file has public read permissions<br>
          3. <strong>File Location:</strong> Verify the file was uploaded to the correct path<br>
          4. <strong>File Format:</strong> Ensure it's a valid CSV file<br><br>
          
          <strong>S3 CORS Configuration Needed:</strong><br>
          <code>
          {<br>
          &nbsp;&nbsp;"AllowedOrigins": ["*"],<br>
          &nbsp;&nbsp;"AllowedMethods": ["GET"],<br>
          &nbsp;&nbsp;"AllowedHeaders": ["*"]<br>
          }
          </code><br><br>
          
          <strong>Check browser console (F12) for detailed error messages.</strong><br>
          <small>App requires real data - no sample data available.</small>
        `;
        parkingSearchStatus.className = 'error';
        
        // Hide results section since no data is available
        parkingResultsSection.style.display = 'none';
      }, 1000);
    }

    // Remove the old sample data function since we now have comprehensive sample data in showCSVInstructions

    // Handle parking location selection
    function onParkingLocationSelected() {
      const place = parkingAutocomplete.getPlace();
      if (!place.geometry) {
        debugLog('No geometry found for selected place');
        return;
      }

      debugLog('Location selected:', place.name);
      parkingMap.setCenter(place.geometry.location);
      parkingMap.setZoom(16);
      
      // Clear previous status and show searching
      parkingSearchStatus.innerText = 'üîç Searching for parking near selected location...';
      parkingSearchStatus.className = 'info';
      
      // Search for nearby parking automatically
      searchNearbyParking(place.geometry.location);
    }

    // Authentication functions
    async function initAuth() {
      debugLog('Initializing authentication');
      
      // For demo purposes, simulate authentication
      isAuthenticated = true;
      userTokens = { accessToken: 'demo-token', idToken: 'demo-id-token' };
      
      const userInfo = { username: 'Demo User', email: 'demo@example.com' };
      
      userGreeting.innerHTML = `Welcome, <strong>${userInfo.username}</strong>`;
      logoutBtn.style.display = 'inline-block';
      
      debugLog('Demo authentication successful');
    }

    function logout() {
      location.reload();
    }

    logoutBtn.addEventListener('click', logout);

    // Event listeners
    searchParkingBtn.addEventListener('click', searchParking);

    parkingLocationInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        searchParking();
      }
    });

    document.getElementById('maxDistanceSelect').addEventListener('change', function() {
      const location = parkingLocationInput.value.trim();
      if (location) {
        debugLog('Distance filter changed, re-searching...');
        searchParking();
      }
    });

    document.getElementById('parkingTypeSelect').addEventListener('change', function() {
      if (parkingResultsSection.style.display !== 'none') {
        debugLog('Parking type filter changed, re-filtering results...');
        const location = parkingLocationInput.value.trim();
        if (location) {
          searchParking();
        }
      }
    });

    function searchParking() {
      const location = parkingLocationInput.value.trim();
      
      if (!location) {
        parkingSearchStatus.innerText = '‚ùå Please enter a location.';
        parkingSearchStatus.className = 'error';
        return;
      }

      parkingSearchStatus.innerText = 'üîç Searching for parking spots...';
      parkingSearchStatus.className = 'info';
      searchParkingBtn.disabled = true;

      // Geocode the location first
      const geocoder = new google.maps.Geocoder();
      geocoder.geocode({ address: location }, (results, status) => {
        if (status === 'OK') {
          const searchLocation = results[0].geometry.location;
          parkingMap.setCenter(searchLocation);
          parkingMap.setZoom(16);
          
          searchNearbyParking(searchLocation);
        } else {
          parkingSearchStatus.innerText = '‚ùå Location not found.';
          parkingSearchStatus.className = 'error';
          searchParkingBtn.disabled = false;
        }
      });
    }

    // Find nearby parking spots from CSV data
    function findNearbyParkingSpots(centerLat, centerLng, radiusKm = 1) {
      if (!melbourneParkingData || melbourneParkingData.length === 0) {
        debugLog('No parking data available');
        return [];
      }

      const spots = melbourneParkingData.filter(spot => {
        if (!spot.Latitude || !spot.Longitude) return false;
        
        // Calculate distance using Haversine formula for better accuracy
        const R = 6371; // Earth's radius in kilometers
        const dLat = (spot.Latitude - centerLat) * Math.PI / 180;
        const dLon = (spot.Longitude - centerLng) * Math.PI / 180;
        const a = 
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(centerLat * Math.PI / 180) * Math.cos(spot.Latitude * Math.PI / 180) * 
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = R * c; // Distance in km
        
        return distance <= radiusKm;
      });
      
      // Sort by distance and return top results
      return spots.map(spot => {
        const R = 6371;
        const dLat = (spot.Latitude - centerLat) * Math.PI / 180;
        const dLon = (spot.Longitude - centerLng) * Math.PI / 180;
        const a = 
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(centerLat * Math.PI / 180) * Math.cos(spot.Latitude * Math.PI / 180) * 
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = R * c * 1000; // Distance in meters
        
        return {
          ...spot,
          distance: Math.round(distance)
        };
      }).sort((a, b) => a.distance - b.distance);
    }

    function searchNearbyParking(location) {
      debugLog('Searching for parking near location:', location.toString());
      
      // Clear existing markers and results
      parkingMarkers.forEach(marker => marker.setMap(null));
      parkingMarkers = [];
      parkingResultsSection.style.display = 'none';

      const maxDistance = parseFloat(document.getElementById('maxDistanceSelect').value);
      
      // Update status
      parkingSearchStatus.innerText = 'üîç Finding parking spots nearby...';
      parkingSearchStatus.className = 'info';

      // Use CSV data to find nearby parking spots
      const nearbySpots = findNearbyParkingSpots(location.lat(), location.lng(), maxDistance);
      
      if (nearbySpots && nearbySpots.length > 0) {
        // Filter based on parking type if needed
        const parkingType = document.getElementById('parkingTypeSelect').value;
        let filteredSpots = nearbySpots;
        
        if (parkingType !== 'all') {
          filteredSpots = nearbySpots.filter(spot => {
            const desc = spot.RoadSegmentDescription ? spot.RoadSegmentDescription.toLowerCase() : '';
            switch (parkingType) {
              case 'street':
                return desc.includes('street') || desc.includes('road') || desc.includes('avenue');
              case 'garage':
                return desc.includes('garage') || desc.includes('building') || desc.includes('car park');
              case 'lot':
                return desc.includes('lot') || desc.includes('park') && !desc.includes('national');
              case 'private':
                return desc.includes('private') || desc.includes('secure');
              default:
                return true;
            }
          });
        }
        
        // Limit to top 20 results for better performance
        const topResults = filteredSpots.slice(0, 20);
        
        displayCSVParkingResults(topResults, location);
        
        // Also add markers for broader area
        const markerResults = filteredSpots.slice(0, 100);
        addAllParkingMarkers(markerResults);
        
        parkingSearchStatus.innerText = `‚úÖ Found ${topResults.length} parking spots nearby (${markerResults.length} shown on map)`;
        parkingSearchStatus.className = 'success';
        parkingResultsSection.style.display = 'block';
      } else {
        parkingSearchStatus.innerText = '‚ùå No parking spots found in this area. Try increasing the search distance.';
        parkingSearchStatus.className = 'error';
      }
      
      // Re-enable search button
      searchParkingBtn.disabled = false;
    }

    function displayCSVParkingResults(spots, searchLocation) {
      // Update results count
      document.getElementById('parkingResultsCount').innerText = 
        `Found ${spots.length} real parking spots from Melbourne data`;

      // Create parking spot cards
      let resultsHTML = '';
      spots.forEach((spot, index) => {
        // Extract street name for cleaner display
        const streetName = spot.RoadSegmentDescription ? 
          spot.RoadSegmentDescription.split(' between')[0] : 'Parking Spot';
        
        // Determine if updated recently (within last year)
        const lastUpdated = new Date(spot.LastUpdated);
        const isRecent = lastUpdated > new Date('2023-01-01');
        
        resultsHTML += `
          <div class="parking-spot">
            <h5>üÖøÔ∏è ${streetName}</h5>
            <div class="parking-info">
              <span>Location:</span>
              <span>${spot.RoadSegmentDescription}</span>
            </div>
            <div class="parking-info">
              <span>Distance:</span>
              <span>${spot.distance}m away</span>
            </div>
            <div class="parking-info">
              <span>Segment ID:</span>
              <span>#${spot.RoadSegmentID}</span>
            </div>
            <div class="parking-info">
              <span>Last Updated:</span>
              <span>${spot.LastUpdated}</span>
            </div>
            ${isRecent ? '<div class="eco-badge">‚úÖ Recently Updated</div>' : ''}
            ${spot.KerbsideID ? '<div class="ev-badge">üè∑Ô∏è Tracked Spot</div>' : ''}
            <div class="parking-actions">
              <button class="navigate-btn" onclick="navigateToParking(${spot.Latitude}, ${spot.Longitude}, '${streetName.replace(/'/g, "\\'")}')">
                üß≠ Navigate
              </button>
            </div>
          </div>
        `;
      });

      parkingResultsGrid.innerHTML = resultsHTML;

      // Don't add markers here since we're using addAllParkingMarkers for better coverage
    }

    // Load real parking data for Melbourne (ALL areas) - ONLY real data, no samples
    function loadRealParkingData() {
      debugLog('loadRealParkingData called');
      parkingSearchStatus.innerText = 'üîç Loading Melbourne parking spots from real data...';
      parkingSearchStatus.className = 'info';
      
      // Clear existing markers
      parkingMarkers.forEach(marker => marker.setMap(null));
      parkingMarkers = [];

      // Check if we have real parking data loaded
      if (!melbourneParkingData || melbourneParkingData.length === 0) {
        debugLog('ERROR: No real parking data available');
        parkingSearchStatus.innerText = '‚ùå No real parking data loaded. Check S3 configuration.';
        parkingSearchStatus.className = 'error';
        parkingResultsSection.style.display = 'none';
        return;
      }

      debugLog(`Processing ${melbourneParkingData.length} real parking data points from entire Melbourne`);

      // Analyze the geographic distribution of real parking data
      const allSpots = melbourneParkingData.map(spot => {
        const distance = Math.round(
          Math.sqrt(
            Math.pow((spot.Latitude - MELBOURNE_CENTER.lat) * 111000, 2) + 
            Math.pow((spot.Longitude - MELBOURNE_CENTER.lng) * 111000, 2)
          )
        );
        return { ...spot, distance };
      });

      // Group spots by distance to see real distribution
      const spotsByDistance = {
        cbd: allSpots.filter(s => s.distance <= 2000),      // Within 2km of center
        inner: allSpots.filter(s => s.distance > 2000 && s.distance <= 10000),  // 2-10km
        outer: allSpots.filter(s => s.distance > 10000)     // Beyond 10km
      };

      debugLog(`Real parking distribution: CBD (${spotsByDistance.cbd.length}), Inner (${spotsByDistance.inner.length}), Outer (${spotsByDistance.outer.length})`);

      // Sample spots from different areas for display (but all from real data)
      const displaySpots = [];
      
      // Add CBD spots
      displaySpots.push(...spotsByDistance.cbd.slice(0, 40));
      
      // Add inner Melbourne spots  
      displaySpots.push(...spotsByDistance.inner.slice(0, 40));
      
      // Add outer Melbourne spots
      displaySpots.push(...spotsByDistance.outer.slice(0, 20));

      // Sort by distance for results display
      const sortedSpots = displaySpots.sort((a, b) => a.distance - b.distance);
      
      debugLog(`Selected ${sortedSpots.length} real parking spots for display across different Melbourne areas`);
      
      if (sortedSpots && sortedSpots.length > 0) {
        displayCSVParkingResults(sortedSpots, { lat: () => MELBOURNE_CENTER.lat, lng: () => MELBOURNE_CENTER.lng });
        parkingSearchStatus.innerText = `‚úÖ Loaded ${allSpots.length} REAL Melbourne parking spots (${spotsByDistance.cbd.length} CBD, ${spotsByDistance.inner.length} inner, ${spotsByDistance.outer.length} outer suburbs)`;
        parkingSearchStatus.className = 'success';
        parkingResultsSection.style.display = 'block';
        
        // Add real parking spots as markers, sampled for performance
        const allMarkerSpots = [];
        // Sample every 10th spot from CBD
        for (let i = 0; i < spotsByDistance.cbd.length; i += 10) {
          allMarkerSpots.push(spotsByDistance.cbd[i]);
        }
        // Sample every 20th spot from inner
        for (let i = 0; i < spotsByDistance.inner.length; i += 20) {
          allMarkerSpots.push(spotsByDistance.inner[i]);
        }
        // Sample every 50th spot from outer
        for (let i = 0; i < spotsByDistance.outer.length; i += 50) {
          allMarkerSpots.push(spotsByDistance.outer[i]);
        }
        
        addAllParkingMarkers(allMarkerSpots);
        debugLog(`Added ${allMarkerSpots.length} markers from real data across all Melbourne areas`);
        
        // Log some sample real locations to verify coverage
        debugLog('Sample REAL outer suburb locations:');
        spotsByDistance.outer.slice(0, 5).forEach(spot => {
          debugLog(`  ${spot.RoadSegmentDescription} - Distance: ${spot.distance}m`);
        });
        
      } else {
        debugLog('No real parking spots available for display');
        parkingSearchStatus.innerText = '‚ùå No real parking data available for display.';
        parkingSearchStatus.className = 'error';
        parkingResultsSection.style.display = 'none';
      }
    }

    // Add function to display many markers on map
    function addAllParkingMarkers(spots) {
      spots.forEach((spot, index) => {
        const marker = new google.maps.Marker({
          position: { lat: spot.Latitude, lng: spot.Longitude },
          map: parkingMap,
          title: `${spot.RoadSegmentDescription} (${spot.distance}m away)`,
          icon: {
            url: 'data:image/svg+xml;base64,' + btoa(`
              <svg width="20" height="20" xmlns="http://www.w3.org/2000/svg">
                <circle cx="10" cy="10" r="8" fill="#4285F4" stroke="#ffffff" stroke-width="2"/>
                <text x="10" y="14" text-anchor="middle" fill="white" font-size="10" font-family="Arial">P</text>
              </svg>
            `),
            scaledSize: new google.maps.Size(20, 20),
            anchor: new google.maps.Point(10, 10)
          }
        });

        // Simple info window
        const infoWindow = new google.maps.InfoWindow({
          content: `
            <div style="padding: 8px; max-width: 200px;">
              <h5>üÖøÔ∏è ${spot.RoadSegmentDescription.length > 50 ? spot.RoadSegmentDescription.substring(0, 50) + '...' : spot.RoadSegmentDescription}</h5>
              <p><strong>Distance:</strong> ${spot.distance}m</p>
              <p><strong>ID:</strong> ${spot.RoadSegmentID}</p>
              <p><strong>Updated:</strong> ${spot.LastUpdated}</p>
            </div>
          `
        });

        marker.addListener('click', () => {
          // Close other info windows
          parkingMarkers.forEach(m => {
            if (m.infoWindow) {
              m.infoWindow.close();
            }
          });
          infoWindow.open(parkingMap, marker);
        });

        marker.infoWindow = infoWindow;
        parkingMarkers.push(marker);
      });

      debugLog(`Added ${spots.length} parking markers to map`);
    }

    // Navigation function to open Google Maps with directions
    function navigateToParking(lat, lng, name) {
      debugLog('Opening navigation to parking spot', { lat, lng, name });
      
      // Create Google Maps URL for navigation
      const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&destination_name=${encodeURIComponent(name)}`;
      
      // Open in new tab/window
      window.open(googleMapsUrl, '_blank');
    }

    // Error handling for Google Maps API
    window.gm_authFailure = function() {
      debugLog('Google Maps API authentication failed');
      document.getElementById('parkingMap').innerHTML = 
        '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f5f5f5; color: #666;"><p>‚ö†Ô∏è Google Maps API key required. Please add your API key to enable maps.</p></div>';
    };

    // Initialize app when page loads
    document.addEventListener('DOMContentLoaded', function() {
      debugLog('Smart Parking Search app initialized');
      
      // If Google Maps fails to load, show fallback
      setTimeout(() => {
        if (typeof google === 'undefined') {
          debugLog('Google Maps API not loaded, showing fallback');
          document.getElementById('parkingMap').innerHTML = 
            '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f5f5f5; color: #666; flex-direction: column;"><p>üó∫Ô∏è Parking Map</p><p style="font-size: 0.9rem; margin-top: 0.5rem;">Add your Google Maps API key to enable full functionality</p></div>';
          
          // Still initialize auth for demo
          initAuth();
        }
      }, 3000);
    });
  </script>
</body>
</html>