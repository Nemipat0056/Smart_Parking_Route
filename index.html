<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Smart Parking Search - Intelligent Parking Solutions</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: #333;
    }

    .header {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    .logo {
      font-size: 1.5rem;
      font-weight: bold;
      color: #667eea;
    }

    .user-section {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .user-greeting {
      font-weight: 500;
    }

    .logout-btn {
      background: #ff6b6b;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    .logout-btn:hover {
      background: #ff5252;
      transform: translateY(-1px);
    }

    .main-container {
      max-width: 1400px;
      margin: 2rem auto;
      padding: 0 2rem;
    }

    .main-content {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 2rem;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    }

    .search-section {
      margin-bottom: 2rem;
    }

    .search-input-group {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }

    input[type="text"], select {
      flex: 1;
      min-width: 200px;
      padding: 1rem;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      font-size: 1rem;
      transition: all 0.3s ease;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    button {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 1rem 2rem;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
      min-width: fit-content;
    }

    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }

    .map-container {
      width: 100%;
      height: 400px;
      border-radius: 12px;
      overflow: hidden;
      margin: 1rem 0;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .parking-filters {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      margin: 1rem 0;
    }

    .parking-filters label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 500;
    }

    .info, .error, .success {
      padding: 1rem;
      border-radius: 12px;
      margin: 1rem 0;
      font-weight: 500;
    }

    .info {
      background: rgba(33, 150, 243, 0.1);
      color: #1976d2;
      border-left: 4px solid #2196f3;
    }

    .error {
      background: rgba(244, 67, 54, 0.1);
      color: #d32f2f;
      border-left: 4px solid #f44336;
    }

    .success {
      background: rgba(76, 175, 80, 0.1);
      color: #388e3c;
      border-left: 4px solid #4caf50;
    }

    .results-section {
      margin-top: 2rem;
    }

    .parking-results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1.5rem;
      margin-top: 1rem;
    }

    .parking-spot {
      background: white;
      padding: 1.5rem;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      border: 1px solid #e0e0e0;
    }

    .parking-spot:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    .parking-spot h5 {
      color: #667eea;
      margin-bottom: 1rem;
    }

    .parking-info {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .parking-info span:first-child {
      font-weight: 500;
      color: #666;
    }
    
    .parking-info span:last-child {
      font-weight: 600;
    }

    .eco-badge, .ev-badge {
      display: inline-block;
      background: #4caf50;
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 6px;
      font-size: 0.8rem;
      margin: 0.25rem 0.25rem 0.25rem 0;
    }
    
    .ev-badge {
      background: #2196f3;
    }

    .parking-actions {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .navigate-btn {
      flex: 1;
      background: #4caf50;
      font-size: 0.9rem;
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .navigate-btn:hover {
      background: #388e3c;
    }

    @media (max-width: 768px) {
      .header {
        padding: 1rem;
        flex-direction: column;
        gap: 1rem;
      }

      .main-container {
        padding: 0 1rem;
      }

      .search-input-group {
        flex-direction: column;
      }

      .parking-results-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <div class="logo">üÖøÔ∏è Smart Parking Search</div>
    <div class="user-section">
      <div id="userGreeting" class="user-greeting">Loading...</div>
      <button id="logoutBtn" class="logout-btn" style="display: none;">Logout</button>
    </div>
  </header>

  <!-- Main Container -->
  <div class="main-container">
    <!-- Main Content -->
    <div class="main-content">
      <h3>üÖøÔ∏è Find Parking Spots</h3>
      
      <!-- Search Section -->
      <div class="search-section">
        <h4>Search for Parking</h4>
        <div class="search-input-group">
          <input type="text" id="parkingLocationInput" placeholder="Enter location or address" />
          <select id="parkingTypeSelect">
            <option value="all">All Types</option>
            <option value="street">Street Parking</option>
            <option value="garage">Parking Garage</option>
            <option value="lot">Parking Lot</option>
            <option value="private">Private Parking</option>
          </select>
          <button id="searchParkingBtn">Search Parking</button>
        </div>
        
        <div class="parking-filters">
          <label>Max Distance: 
            <select id="maxDistanceSelect">
              <option value="0.5">0.5 km</option>
              <option value="1" selected>1 km</option>
              <option value="2">2 km</option>
              <option value="5">5 km</option>
            </select>
          </label>
          
          <label>Price Range: 
            <select id="priceRangeSelect">
              <option value="all">Any Price</option>
              <option value="free">Free</option>
              <option value="low">$0-$5/hour</option>
              <option value="medium">$5-$15/hour</option>
              <option value="high">$15+/hour</option>
            </select>
          </label>
        </div>
        
        <div id="parkingSearchStatus" class="info">Ready to search for parking spots</div>
        
        <!-- Google Map for Parking Search -->
        <div id="parkingMap" class="map-container"></div>
      </div>

      <!-- Parking Results Section -->
      <div id="parkingResultsSection" class="results-section" style="display: none;">
        <h4>Available Parking Spots</h4>
        <div id="parkingResultsCount" class="results-count"></div>
        <div id="parkingResultsGrid" class="parking-results-grid"></div>
      </div>
    </div>
  </div>

  <!-- Google Maps API -->
  <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDwXzBClakuchQF0zxKk0UBkPhLX--d7tg&libraries=places&callback=initMaps"></script>

  <script>
    // Google Maps Configuration
    let parkingMap;
    let placesService;
    let parkingAutocomplete;
    let parkingMarkers = [];

    // Melbourne CBD coordinates
    const MELBOURNE_CBD = { lat: -37.8136, lng: 144.9631 };

    // Global variables
    let userTokens = null;
    let isAuthenticated = false;
    let melbourneParkingData = [];

    // DOM elements
    const userGreeting = document.getElementById('userGreeting');
    const logoutBtn = document.getElementById('logoutBtn');
    const parkingLocationInput = document.getElementById('parkingLocationInput');
    const searchParkingBtn = document.getElementById('searchParkingBtn');
    const parkingSearchStatus = document.getElementById('parkingSearchStatus');
    const parkingResultsSection = document.getElementById('parkingResultsSection');
    const parkingResultsGrid = document.getElementById('parkingResultsGrid');

    // Debug mode
    const DEBUG_MODE = true;

    function debugLog(message, data = null) {
      if (DEBUG_MODE) {
        console.log(`[Smart Parking Search DEBUG] ${message}`, data);
      }
    }

    // Initialize Google Maps
    async function initMaps() {
      debugLog('Initializing Google Maps');
      
      // Load parking data first
      await loadParkingData();
      
      // Initialize parking search map
      parkingMap = new google.maps.Map(document.getElementById('parkingMap'), {
        zoom: 15,
        center: MELBOURNE_CBD,
        styles: [
          {
            featureType: 'poi',
            elementType: 'labels',
            stylers: [{ visibility: 'off' }]
          }
        ]
      });

      // Initialize places service
      placesService = new google.maps.places.PlacesService(parkingMap);

      // Setup autocomplete for parking search
      parkingAutocomplete = new google.maps.places.Autocomplete(
        parkingLocationInput,
        {
          bounds: new google.maps.LatLngBounds(
            new google.maps.LatLng(-37.9, 144.8),
            new google.maps.LatLng(-37.7, 145.1)
          ),
          strictBounds: true
        }
      );

      parkingAutocomplete.addListener('place_changed', onParkingLocationSelected);

      debugLog('Google Maps initialized successfully');
      
      // Initialize authentication after maps are ready
      initAuth();
      
      // Load real parking data for Melbourne CBD by default
      setTimeout(() => {
        if (melbourneParkingData.length > 0) {
          loadRealParkingData();
        } else {
          // If data isn't loaded yet, try again
          setTimeout(() => {
            loadRealParkingData();
          }, 2000);
        }
      }, 1000);
      
      // Also set the input to show Melbourne CBD as default
      parkingLocationInput.value = "Melbourne CBD, VIC, Australia";
    }

    // Load parking data from CSV
    async function loadParkingData() {
      try {
        debugLog('Loading parking data from CSV...');
        
        // Check if window.fs is available
        if (!window.fs || !window.fs.readFile) {
          debugLog('window.fs.readFile not available');
          // Create sample data for demonstration
          createSampleParkingData();
          return;
        }

        const csvContent = await window.fs.readFile('on-street-parking-bays.csv', { encoding: 'utf8' });
        
        if (!csvContent) {
          debugLog('CSV content is empty or undefined');
          createSampleParkingData();
          return;
        }

        debugLog('CSV content loaded, first 200 chars:', csvContent.substring(0, 200));
        
        // Simple CSV parser since we know the structure
        const lines = csvContent.split('\n');
        if (lines.length < 2) {
          debugLog('CSV has insufficient lines:', lines.length);
          createSampleParkingData();
          return;
        }

        const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
        debugLog('CSV headers:', headers);
        
        melbourneParkingData = [];
        let validRows = 0;
        
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;
          
          // Parse CSV line handling quoted values
          const values = [];
          let currentValue = '';
          let inQuotes = false;
          
          for (let j = 0; j < line.length; j++) {
            const char = line[j];
            if (char === '"') {
              inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
              values.push(currentValue.trim().replace(/"/g, ''));
              currentValue = '';
            } else {
              currentValue += char;
            }
          }
          values.push(currentValue.trim().replace(/"/g, ''));
          
          // Create parking spot object
          const spot = {};
          headers.forEach((header, index) => {
            let value = values[index] || '';
            
            // Convert numeric fields
            if (header === 'RoadSegmentID' && value) {
              spot[header] = parseInt(value);
            } else if (header === 'KerbsideID' && value) {
              spot[header] = parseInt(value);
            } else if ((header === 'Latitude' || header === 'Longitude') && value) {
              spot[header] = parseFloat(value);
            } else {
              spot[header] = value;
            }
          });
          
          // Only add spots with valid coordinates and descriptions
          if (spot.Latitude && spot.Longitude && spot.RoadSegmentDescription && 
              !isNaN(spot.Latitude) && !isNaN(spot.Longitude)) {
            melbourneParkingData.push(spot);
            validRows++;
          }
        }
        
        debugLog(`Loaded ${melbourneParkingData.length} valid parking spots from CSV (${validRows} processed)`);
        
        if (melbourneParkingData.length === 0) {
          debugLog('No valid parking data found, creating sample data');
          createSampleParkingData();
        }
        
      } catch (error) {
        debugLog('Error loading parking data:', error);
        createSampleParkingData();
      }
    }

    // Create sample parking data as fallback
    function createSampleParkingData() {
      debugLog('Creating sample parking data...');
      
      melbourneParkingData = [
        {
          RoadSegmentID: 20189,
          KerbsideID: 56721,
          RoadSegmentDescription: "King Street between Flinders Lane and Collins Street",
          Latitude: -37.8185369,
          Longitude: 144.9568504,
          LastUpdated: "2024-04-08",
          Location: "-37.8185369, 144.9568504"
        },
        {
          RoadSegmentID: 20172,
          KerbsideID: null,
          RoadSegmentDescription: "Queen Street between Collins Street and Little Collins Street",
          Latitude: -37.8163667,
          Longitude: 144.9612159,
          LastUpdated: "2023-11-21",
          Location: "-37.8163667, 144.9612159"
        },
        {
          RoadSegmentID: 20014,
          KerbsideID: null,
          RoadSegmentDescription: "Lonsdale Street between King Street and Spencer Street",
          Latitude: -37.8148461,
          Longitude: 144.9536493,
          LastUpdated: "2023-10-31",
          Location: "-37.8148461, 144.9536493"
        },
        {
          RoadSegmentID: 22213,
          KerbsideID: null,
          RoadSegmentDescription: "Collins Street between Queen Street and Elizabeth Street",
          Latitude: -37.8136,
          Longitude: 144.9631,
          LastUpdated: "2024-01-15",
          Location: "-37.8136, 144.9631"
        },
        {
          RoadSegmentID: 22214,
          KerbsideID: 12345,
          RoadSegmentDescription: "Bourke Street between Swanston Street and Russell Street",
          Latitude: -37.8141,
          Longitude: 144.9655,
          LastUpdated: "2024-02-01",
          Location: "-37.8141, 144.9655"
        },
        {
          RoadSegmentID: 22215,
          KerbsideID: null,
          RoadSegmentDescription: "Flinders Street between Elizabeth Street and Swanston Street",
          Latitude: -37.8183,
          Longitude: 144.9671,
          LastUpdated: "2024-03-10",
          Location: "-37.8183, 144.9671"
        },
        {
          RoadSegmentID: 22216,
          KerbsideID: 67890,
          RoadSegmentDescription: "Spencer Street between Collins Street and Bourke Street",
          Latitude: -37.8156,
          Longitude: 144.9506,
          LastUpdated: "2024-01-20",
          Location: "-37.8156, 144.9506"
        },
        {
          RoadSegmentID: 22217,
          KerbsideID: null,
          RoadSegmentDescription: "Elizabeth Street between Flinders Street and Collins Street",
          Latitude: -37.8167,
          Longitude: 144.9612,
          LastUpdated: "2023-12-15",
          Location: "-37.8167, 144.9612"
        },
        {
          RoadSegmentID: 22218,
          KerbsideID: 11111,
          RoadSegmentDescription: "Russell Street between Collins Street and Bourke Street",
          Latitude: -37.8149,
          Longitude: 144.9697,
          LastUpdated: "2024-02-28",
          Location: "-37.8149, 144.9697"
        },
        {
          RoadSegmentID: 22219,
          KerbsideID: null,
          RoadSegmentDescription: "Little Collins Street between Queen Street and Elizabeth Street",
          Latitude: -37.8147,
          Longitude: 144.9615,
          LastUpdated: "2024-01-05",
          Location: "-37.8147, 144.9615"
        }
      ];
      
      debugLog(`Created ${melbourneParkingData.length} sample parking spots`);
    }

    // Handle parking location selection
    function onParkingLocationSelected() {
      const place = parkingAutocomplete.getPlace();
      if (!place.geometry) {
        debugLog('No geometry found for selected place');
        return;
      }

      debugLog('Location selected:', place.name);
      parkingMap.setCenter(place.geometry.location);
      parkingMap.setZoom(16);
      
      // Clear previous status and show searching
      parkingSearchStatus.innerText = 'üîç Searching for parking near selected location...';
      parkingSearchStatus.className = 'info';
      
      // Search for nearby parking automatically
      searchNearbyParking(place.geometry.location);
    }

    // Authentication functions
    async function initAuth() {
      debugLog('Initializing authentication');
      
      // For demo purposes, simulate authentication
      isAuthenticated = true;
      userTokens = { accessToken: 'demo-token', idToken: 'demo-id-token' };
      
      const userInfo = { username: 'Demo User', email: 'demo@example.com' };
      
      userGreeting.innerHTML = `Welcome, <strong>${userInfo.username}</strong>`;
      logoutBtn.style.display = 'inline-block';
      
      debugLog('Demo authentication successful');
    }

    function logout() {
      location.reload();
    }

    logoutBtn.addEventListener('click', logout);

    // Event listeners
    searchParkingBtn.addEventListener('click', searchParking);

    parkingLocationInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        searchParking();
      }
    });

    document.getElementById('maxDistanceSelect').addEventListener('change', function() {
      const location = parkingLocationInput.value.trim();
      if (location) {
        debugLog('Distance filter changed, re-searching...');
        searchParking();
      }
    });

    document.getElementById('parkingTypeSelect').addEventListener('change', function() {
      if (parkingResultsSection.style.display !== 'none') {
        debugLog('Parking type filter changed, re-filtering results...');
        const location = parkingLocationInput.value.trim();
        if (location) {
          searchParking();
        }
      }
    });

    function searchParking() {
      const location = parkingLocationInput.value.trim();
      
      if (!location) {
        parkingSearchStatus.innerText = '‚ùå Please enter a location.';
        parkingSearchStatus.className = 'error';
        return;
      }

      parkingSearchStatus.innerText = 'üîç Searching for parking spots...';
      parkingSearchStatus.className = 'info';
      searchParkingBtn.disabled = true;

      // Geocode the location first
      const geocoder = new google.maps.Geocoder();
      geocoder.geocode({ address: location }, (results, status) => {
        if (status === 'OK') {
          const searchLocation = results[0].geometry.location;
          parkingMap.setCenter(searchLocation);
          parkingMap.setZoom(16);
          
          searchNearbyParking(searchLocation);
        } else {
          parkingSearchStatus.innerText = '‚ùå Location not found.';
          parkingSearchStatus.className = 'error';
          searchParkingBtn.disabled = false;
        }
      });
    }

    // Find nearby parking spots from CSV data
    function findNearbyParkingSpots(centerLat, centerLng, radiusKm = 1) {
      if (!melbourneParkingData || melbourneParkingData.length === 0) {
        debugLog('No parking data available');
        return [];
      }

      const spots = melbourneParkingData.filter(spot => {
        if (!spot.Latitude || !spot.Longitude) return false;
        
        // Calculate distance using Haversine formula for better accuracy
        const R = 6371; // Earth's radius in kilometers
        const dLat = (spot.Latitude - centerLat) * Math.PI / 180;
        const dLon = (spot.Longitude - centerLng) * Math.PI / 180;
        const a = 
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(centerLat * Math.PI / 180) * Math.cos(spot.Latitude * Math.PI / 180) * 
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = R * c; // Distance in km
        
        return distance <= radiusKm;
      });
      
      // Sort by distance and return top results
      return spots.map(spot => {
        const R = 6371;
        const dLat = (spot.Latitude - centerLat) * Math.PI / 180;
        const dLon = (spot.Longitude - centerLng) * Math.PI / 180;
        const a = 
          Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(centerLat * Math.PI / 180) * Math.cos(spot.Latitude * Math.PI / 180) * 
          Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = R * c * 1000; // Distance in meters
        
        return {
          ...spot,
          distance: Math.round(distance)
        };
      }).sort((a, b) => a.distance - b.distance);
    }

    function searchNearbyParking(location) {
      debugLog('Searching for parking near location:', location.toString());
      
      // Clear existing markers and results
      parkingMarkers.forEach(marker => marker.setMap(null));
      parkingMarkers = [];
      parkingResultsSection.style.display = 'none';

      const maxDistance = parseFloat(document.getElementById('maxDistanceSelect').value);
      
      // Update status
      parkingSearchStatus.innerText = 'üîç Finding parking spots nearby...';
      parkingSearchStatus.className = 'info';

      // Use CSV data to find nearby parking spots
      const nearbySpots = findNearbyParkingSpots(location.lat(), location.lng(), maxDistance);
      
      if (nearbySpots && nearbySpots.length > 0) {
        // Filter based on parking type if needed
        const parkingType = document.getElementById('parkingTypeSelect').value;
        let filteredSpots = nearbySpots;
        
        if (parkingType !== 'all') {
          filteredSpots = nearbySpots.filter(spot => {
            const desc = spot.RoadSegmentDescription ? spot.RoadSegmentDescription.toLowerCase() : '';
            switch (parkingType) {
              case 'street':
                return desc.includes('street') || desc.includes('road') || desc.includes('avenue');
              case 'garage':
                return desc.includes('garage') || desc.includes('building') || desc.includes('car park');
              case 'lot':
                return desc.includes('lot') || desc.includes('park') && !desc.includes('national');
              case 'private':
                return desc.includes('private') || desc.includes('secure');
              default:
                return true;
            }
          });
        }
        
        // Limit to top 20 results for better performance
        const topResults = filteredSpots.slice(0, 20);
        
        displayCSVParkingResults(topResults, location);
        
        // Also add markers for broader area
        const markerResults = filteredSpots.slice(0, 100);
        addAllParkingMarkers(markerResults);
        
        parkingSearchStatus.innerText = `‚úÖ Found ${topResults.length} parking spots nearby (${markerResults.length} shown on map)`;
        parkingSearchStatus.className = 'success';
        parkingResultsSection.style.display = 'block';
      } else {
        parkingSearchStatus.innerText = '‚ùå No parking spots found in this area. Try increasing the search distance.';
        parkingSearchStatus.className = 'error';
      }
      
      // Re-enable search button
      searchParkingBtn.disabled = false;
    }

    function displayCSVParkingResults(spots, searchLocation) {
      // Update results count
      document.getElementById('parkingResultsCount').innerText = 
        `Found ${spots.length} real parking spots from Melbourne data`;

      // Create parking spot cards
      let resultsHTML = '';
      spots.forEach((spot, index) => {
        // Extract street name for cleaner display
        const streetName = spot.RoadSegmentDescription ? 
          spot.RoadSegmentDescription.split(' between')[0] : 'Parking Spot';
        
        // Determine if updated recently (within last year)
        const lastUpdated = new Date(spot.LastUpdated);
        const isRecent = lastUpdated > new Date('2023-01-01');
        
        resultsHTML += `
          <div class="parking-spot">
            <h5>üÖøÔ∏è ${streetName}</h5>
            <div class="parking-info">
              <span>Location:</span>
              <span>${spot.RoadSegmentDescription}</span>
            </div>
            <div class="parking-info">
              <span>Distance:</span>
              <span>${spot.distance}m away</span>
            </div>
            <div class="parking-info">
              <span>Segment ID:</span>
              <span>#${spot.RoadSegmentID}</span>
            </div>
            <div class="parking-info">
              <span>Last Updated:</span>
              <span>${spot.LastUpdated}</span>
            </div>
            ${isRecent ? '<div class="eco-badge">‚úÖ Recently Updated</div>' : ''}
            ${spot.KerbsideID ? '<div class="ev-badge">üè∑Ô∏è Tracked Spot</div>' : ''}
            <div class="parking-actions">
              <button class="navigate-btn" onclick="navigateToParking(${spot.Latitude}, ${spot.Longitude}, '${streetName.replace(/'/g, "\\'")}')">
                üß≠ Navigate
              </button>
            </div>
          </div>
        `;
      });

      parkingResultsGrid.innerHTML = resultsHTML;

      // Don't add markers here since we're using addAllParkingMarkers for better coverage
    }

    // Load real parking data for Melbourne CBD
    function loadRealParkingData() {
      debugLog('loadRealParkingData called');
      parkingSearchStatus.innerText = 'üîç Loading Melbourne CBD parking spots...';
      parkingSearchStatus.className = 'info';
      
      // Clear existing markers
      parkingMarkers.forEach(marker => marker.setMap(null));
      parkingMarkers = [];

      // Check if we have parking data loaded
      if (!melbourneParkingData || melbourneParkingData.length === 0) {
        debugLog('No parking data available, showing error and retrying...');
        parkingSearchStatus.innerText = '‚ùå Parking data not loaded yet. Please wait...';
        parkingSearchStatus.className = 'error';
        // Try to load data again after a delay
        setTimeout(() => {
          debugLog('Retrying data load...');
          loadParkingData().then(() => {
            if (melbourneParkingData.length > 0) {
              debugLog('Data loaded on retry, calling loadRealParkingData again');
              loadRealParkingData();
            } else {
              debugLog('Still no data after retry');
              parkingSearchStatus.innerText = '‚ùå Unable to load parking data. Using sample data instead.';
              parkingSearchStatus.className = 'error';
            }
          });
        }, 2000);
        return;
      }

      debugLog(`Processing ${melbourneParkingData.length} parking data points`);

      // Use CSV data to find CBD parking spots
      const cbdSpots = findNearbyParkingSpots(MELBOURNE_CBD.lat, MELBOURNE_CBD.lng, 3); // Increased to 3km radius
      
      debugLog(`Found ${cbdSpots.length} CBD parking spots from CSV data`);
      
      if (cbdSpots && cbdSpots.length > 0) {
        // Limit to top 50 spots for initial display
        const topCBDSpots = cbdSpots.slice(0, 50);
        
        displayCSVParkingResults(topCBDSpots, { lat: () => MELBOURNE_CBD.lat, lng: () => MELBOURNE_CBD.lng });
        parkingSearchStatus.innerText = `‚úÖ Loaded ${topCBDSpots.length} Melbourne CBD parking spots from real data`;
        parkingSearchStatus.className = 'success';
        parkingResultsSection.style.display = 'block';
        
        // Also add all spots as markers to the map for better visibility
        addAllParkingMarkers(cbdSpots.slice(0, 200)); // Add more markers to map
      } else {
        debugLog('No CBD spots found');
        parkingSearchStatus.innerText = '‚ùå No parking spots found in CBD area. Data may be incomplete.';
        parkingSearchStatus.className = 'error';
        
        // Show some sample markers anyway
        if (melbourneParkingData.length > 0) {
          const sampleSpots = melbourneParkingData.slice(0, 10).map(spot => ({
            ...spot,
            distance: Math.round(Math.random() * 1000)
          }));
          displayCSVParkingResults(sampleSpots, { lat: () => MELBOURNE_CBD.lat, lng: () => MELBOURNE_CBD.lng });
          addAllParkingMarkers(sampleSpots);
          parkingSearchStatus.innerText = `‚úÖ Showing ${sampleSpots.length} sample parking spots`;
          parkingSearchStatus.className = 'success';
          parkingResultsSection.style.display = 'block';
        }
      }
    }

    // Add function to display many markers on map
    function addAllParkingMarkers(spots) {
      spots.forEach((spot, index) => {
        const marker = new google.maps.Marker({
          position: { lat: spot.Latitude, lng: spot.Longitude },
          map: parkingMap,
          title: `${spot.RoadSegmentDescription} (${spot.distance}m away)`,
          icon: {
            url: 'data:image/svg+xml;base64,' + btoa(`
              <svg width="20" height="20" xmlns="http://www.w3.org/2000/svg">
                <circle cx="10" cy="10" r="8" fill="#4285F4" stroke="#ffffff" stroke-width="2"/>
                <text x="10" y="14" text-anchor="middle" fill="white" font-size="10" font-family="Arial">P</text>
              </svg>
            `),
            scaledSize: new google.maps.Size(20, 20),
            anchor: new google.maps.Point(10, 10)
          }
        });

        // Simple info window
        const infoWindow = new google.maps.InfoWindow({
          content: `
            <div style="padding: 8px; max-width: 200px;">
              <h5>üÖøÔ∏è ${spot.RoadSegmentDescription.length > 50 ? spot.RoadSegmentDescription.substring(0, 50) + '...' : spot.RoadSegmentDescription}</h5>
              <p><strong>Distance:</strong> ${spot.distance}m</p>
              <p><strong>ID:</strong> ${spot.RoadSegmentID}</p>
              <p><strong>Updated:</strong> ${spot.LastUpdated}</p>
            </div>
          `
        });

        marker.addListener('click', () => {
          // Close other info windows
          parkingMarkers.forEach(m => {
            if (m.infoWindow) {
              m.infoWindow.close();
            }
          });
          infoWindow.open(parkingMap, marker);
        });

        marker.infoWindow = infoWindow;
        parkingMarkers.push(marker);
      });

      debugLog(`Added ${spots.length} parking markers to map`);
    }

    // Navigation function to open Google Maps with directions
    function navigateToParking(lat, lng, name) {
      debugLog('Opening navigation to parking spot', { lat, lng, name });
      
      // Create Google Maps URL for navigation
      const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&destination_name=${encodeURIComponent(name)}`;
      
      // Open in new tab/window
      window.open(googleMapsUrl, '_blank');
    }

    // Error handling for Google Maps API
    window.gm_authFailure = function() {
      debugLog('Google Maps API authentication failed');
      document.getElementById('parkingMap').innerHTML = 
        '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f5f5f5; color: #666;"><p>‚ö†Ô∏è Google Maps API key required. Please add your API key to enable maps.</p></div>';
    };

    // Initialize app when page loads
    document.addEventListener('DOMContentLoaded', function() {
      debugLog('Smart Parking Search app initialized');
      
      // If Google Maps fails to load, show fallback
      setTimeout(() => {
        if (typeof google === 'undefined') {
          debugLog('Google Maps API not loaded, showing fallback');
          document.getElementById('parkingMap').innerHTML = 
            '<div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #f5f5f5; color: #666; flex-direction: column;"><p>üó∫Ô∏è Parking Map</p><p style="font-size: 0.9rem; margin-top: 0.5rem;">Add your Google Maps API key to enable full functionality</p></div>';
          
          // Still initialize auth for demo
          initAuth();
        }
      }, 3000);
    });
  </script>
</body>
</html>